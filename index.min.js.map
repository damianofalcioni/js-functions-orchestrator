{
  "version": 3,
  "sources": ["node_modules/jsonata/jsonata.js", "index.js"],
  "sourcesContent": ["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.jsonata = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * \u00A9 Copyright IBM Corp. 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = require('./utils');\n\n/**\n * DateTime formatting and parsing functions\n * Implements the xpath-functions format-date-time specification\n * @type {{formatInteger, formatDateTime, parseInteger, parseDateTime}}\n */\nconst dateTime = (function () {\n    'use strict';\n\n    const stringToArray = utils.stringToArray;\n\n    const few = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten',\n        'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];\n    const ordinals = ['Zeroth', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth',\n        'Eleventh', 'Twelfth', 'Thirteenth', 'Fourteenth', 'Fifteenth', 'Sixteenth', 'Seventeenth', 'Eighteenth', 'Nineteenth'];\n    const decades = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'Hundred'];\n    const magnitudes = ['Thousand', 'Million', 'Billion', 'Trillion'];\n\n    /**\n     * converts a number into english words\n     * @param {string} value - the value to format\n     * @param {boolean} ordinal - ordinal or cardinal form\n     * @returns {string} - representation in words\n     */\n    function numberToWords(value, ordinal) {\n        var lookup = function (num, prev, ord) {\n            var words = '';\n            if (num <= 19) {\n                words = (prev ? ' and ' : '') + (ord ? ordinals[num] : few[num]);\n            } else if (num < 100) {\n                const tens = Math.floor(num / 10);\n                const remainder = num % 10;\n                words = (prev ? ' and ' : '') + decades[tens - 2];\n                if (remainder > 0) {\n                    words += '-' + lookup(remainder, false, ord);\n                } else if (ord) {\n                    words = words.substring(0, words.length - 1) + 'ieth';\n                }\n            } else if (num < 1000) {\n                const hundreds = Math.floor(num / 100);\n                const remainder = num % 100;\n                words = (prev ? ', ' : '') + few[hundreds] + ' Hundred';\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            } else {\n                var mag = Math.floor(Math.log10(num) / 3);\n                if (mag > magnitudes.length) {\n                    mag = magnitudes.length; // the largest word\n                }\n                const factor = Math.pow(10, mag * 3);\n                const mant = Math.floor(num / factor);\n                const remainder = num - mant * factor;\n                words = (prev ? ', ' : '') + lookup(mant, false, false) + ' ' + magnitudes[mag - 1];\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            }\n            return words;\n        };\n\n        var words = lookup(value, false, ordinal);\n        return words;\n    }\n\n    const wordValues = {};\n    few.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    ordinals.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    decades.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        wordValues[lword] = (index + 2) * 10;\n        wordValues[lword.substring(0, word.length - 1) + 'ieth'] = wordValues[lword];\n    });\n    wordValues.hundredth = 100;\n    magnitudes.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        const val = Math.pow(10, (index + 1) * 3);\n        wordValues[lword] = val;\n        wordValues[lword + 'th'] = val;\n    });\n\n    /**\n     * Converts a number in english words to numeric value\n     * @param {string} text - the number in words\n     * @returns {number} - the numeric value\n     */\n    function wordsToNumber(text) {\n        const parts = text.split(/,\\s|\\sand\\s|[\\s\\\\-]/);\n        const values = parts.map(part => wordValues[part]);\n        let segs = [0];\n        values.forEach(value => {\n            if (value < 100) {\n                let top = segs.pop();\n                if (top >= 1000) {\n                    segs.push(top);\n                    top = 0;\n                }\n                segs.push(top + value);\n            } else {\n                segs.push(segs.pop() * value);\n            }\n        });\n        const result = segs.reduce((a, b) => a + b, 0);\n        return result;\n    }\n\n    const romanNumerals = [\n        [1000, 'm'],\n        [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i']\n    ];\n\n    const romanValues = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1};\n\n    /**\n     * converts a number to roman numerals\n     * @param {number} value - the number\n     * @returns {string} - the number in roman numerals\n     */\n    function decimalToRoman(value) {\n        for (var index = 0; index < romanNumerals.length; index++) {\n            const numeral = romanNumerals[index];\n            if (value >= numeral[0]) {\n                return numeral[1] + decimalToRoman(value - numeral[0]);\n            }\n        }\n        return '';\n    }\n\n    /**\n     * converts roman numerals to a number\n     * @param {string} roman - roman number\n     * @returns {number} - the numeric value\n     */\n    function romanToDecimal(roman) {\n        var decimal = 0;\n        var max = 1;\n        for (var i = roman.length - 1; i >= 0; i--) {\n            const digit = roman[i];\n            const value = romanValues[digit];\n            if (value < max) {\n                decimal -= value;\n            } else {\n                max = value;\n                decimal += value;\n            }\n        }\n        return decimal;\n    }\n\n    /**\n     * converts a number to spreadsheet style letters\n     * @param {number} value - the number\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {string} - the letters\n     */\n    function decimalToLetters(value, aChar) {\n        var letters = [];\n        var aCode = aChar.charCodeAt(0);\n        while (value > 0) {\n            letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));\n            value = Math.floor((value - 1) / 26);\n        }\n        return letters.join('');\n    }\n\n    /**\n     * converts spreadsheet style letters to a number\n     * @param {string} letters - the letters\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {number} - the numeric value\n     */\n    function lettersToDecimal(letters, aChar) {\n        var aCode = aChar.charCodeAt(0);\n        var decimal = 0;\n        for (var i = 0; i < letters.length; i++) {\n            decimal += (letters.charCodeAt(letters.length - i - 1) - aCode + 1) * Math.pow(26, i);\n        }\n        return decimal;\n    }\n\n    /**\n     * Formats an integer as specified by the XPath fn:format-integer function\n     * See https://www.w3.org/TR/xpath-functions-31/#func-format-integer\n     * @param {number} value - the number to be formatted\n     * @param {string} picture - the picture string that specifies the format\n     * @returns {string} - the formatted number\n     */\n    function formatInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = Math.floor(value);\n\n        const format = analyseIntegerPicture(picture);\n        return _formatInteger(value, format);\n    }\n\n    const formats = {\n        DECIMAL: 'decimal',\n        LETTERS: 'letters',\n        ROMAN: 'roman',\n        WORDS: 'words',\n        SEQUENCE: 'sequence'\n    };\n\n    const tcase = {\n        UPPER: 'upper',\n        LOWER: 'lower',\n        TITLE: 'title'\n    };\n\n    /**\n     * formats an integer using a preprocessed representation of the picture string\n     * @param {number} value - the number to be formatted\n     * @param {object} format - the preprocessed representation of the pucture string\n     * @returns {string} - the formatted number\n     * @private\n     */\n    function _formatInteger(value, format) {\n        let formattedInteger;\n        const negative = value < 0;\n        value = Math.abs(value);\n        switch (format.primary) {\n            case formats.LETTERS:\n                formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? 'A' : 'a');\n                break;\n            case formats.ROMAN:\n                formattedInteger = decimalToRoman(value);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                }\n                break;\n            case formats.WORDS:\n                formattedInteger = numberToWords(value, format.ordinal);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                } else if (format.case === tcase.LOWER) {\n                    formattedInteger = formattedInteger.toLowerCase();\n                }\n                break;\n            case formats.DECIMAL:\n                formattedInteger = '' + value;\n                // TODO use functionPad\n                var padLength = format.mandatoryDigits - formattedInteger.length;\n                if (padLength > 0) {\n                    var padding = (new Array(padLength + 1)).join('0');\n                    formattedInteger = padding + formattedInteger;\n                }\n                if (format.zeroCode !== 0x30) {\n                    formattedInteger = stringToArray(formattedInteger).map(code => {\n                        return String.fromCodePoint(code.codePointAt(0) + format.zeroCode - 0x30);\n                    }).join('');\n                }\n                // insert the grouping-separator-signs, if any\n                if (format.regular) {\n                    const n = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);\n                    for (let ii = n; ii > 0; ii--) {\n                        const pos = formattedInteger.length - ii * format.groupingSeparators.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);\n                    }\n                } else {\n                    format.groupingSeparators.reverse().forEach(separator => {\n                        const pos = formattedInteger.length - separator.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);\n                    });\n                }\n\n                if (format.ordinal) {\n                    var suffix123 = {'1': 'st', '2': 'nd', '3': 'rd'};\n                    var lastDigit = formattedInteger[formattedInteger.length - 1];\n                    var suffix = suffix123[lastDigit];\n                    if (!suffix || (formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === '1')) {\n                        suffix = 'th';\n                    }\n                    formattedInteger = formattedInteger + suffix;\n                }\n                break;\n            case formats.SEQUENCE:\n                throw {\n                    code: 'D3130',\n                    value: format.token\n                };\n        }\n        if (negative) {\n            formattedInteger = '-' + formattedInteger;\n        }\n\n        return formattedInteger;\n    }\n\n    //TODO what about decimal groups in the unicode supplementary planes (surrogate pairs) ???\n    const decimalGroups = [0x30, 0x0660, 0x06F0, 0x07C0, 0x0966, 0x09E6, 0x0A66, 0x0AE6, 0x0B66, 0x0BE6, 0x0C66, 0x0CE6, 0x0D66, 0x0DE6, 0x0E50, 0x0ED0, 0x0F20, 0x1040, 0x1090, 0x17E0, 0x1810, 0x1946, 0x19D0, 0x1A80, 0x1A90, 0x1B50, 0x1BB0, 0x1C40, 0x1C50, 0xA620, 0xA8D0, 0xA900, 0xA9D0, 0xA9F0, 0xAA50, 0xABF0, 0xFF10];\n\n    /**\n     * preprocesses the picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, primary: string, case: string, ordinal: boolean}} - analysed picture\n     */\n    function analyseIntegerPicture(picture) {\n        const format = {\n            type: 'integer',\n            primary: formats.DECIMAL,\n            case: tcase.LOWER,\n            ordinal: false\n        };\n\n        let primaryFormat, formatModifier;\n        const semicolon = picture.lastIndexOf(';');\n        if (semicolon === -1) {\n            primaryFormat = picture;\n        } else {\n            primaryFormat = picture.substring(0, semicolon);\n            formatModifier = picture.substring(semicolon + 1);\n            if (formatModifier[0] === 'o') {\n                format.ordinal = true;\n            }\n        }\n\n        /* eslnt-disable-next no-fallthrough */\n        switch (primaryFormat) {\n            case 'A':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'a':\n                format.primary = formats.LETTERS;\n                break;\n            case 'I':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'i':\n                format.primary = formats.ROMAN;\n                break;\n            case 'W':\n                format.case = tcase.UPPER;\n                format.primary = formats.WORDS;\n                break;\n            case 'Ww':\n                format.case = tcase.TITLE;\n                format.primary = formats.WORDS;\n                break;\n            case 'w':\n                format.primary = formats.WORDS;\n                break;\n            default: {\n                // this is a decimal-digit-pattern if it contains a decimal digit (from any unicode decimal digit group)\n                let zeroCode = null;\n                let mandatoryDigits = 0;\n                let optionalDigits = 0;\n                let groupingSeparators = [];\n                let separatorPosition = 0;\n                const formatCodepoints = stringToArray(primaryFormat).map(c => c.codePointAt(0)).reverse(); // reverse the array to determine positions of grouping-separator-signs\n                formatCodepoints.forEach((codePoint) => {\n                    // step though each char in the picture to determine the digit group\n                    let digit = false;\n                    for (let ii = 0; ii < decimalGroups.length; ii++) {\n                        const group = decimalGroups[ii];\n                        if (codePoint >= group && codePoint <= group + 9) {\n                            // codepoint is part of this decimal group\n                            digit = true;\n                            mandatoryDigits++;\n                            separatorPosition++;\n                            if (zeroCode === null) {\n                                zeroCode = group;\n                            } else if (group !== zeroCode) {\n                                // error! different decimal groups in the same pattern\n                                throw {\n                                    code: 'D3131'\n                                };\n                            }\n                            break;\n                        }\n                    }\n                    if (!digit) {\n                        if (codePoint === 0x23) { // # - optional-digit-sign\n                            separatorPosition++;\n                            optionalDigits++;\n                        } else {\n                            // neither a decimal-digit-sign ot optional-digit-sign, assume it is a grouping-separator-sign\n                            groupingSeparators.push({\n                                position: separatorPosition,\n                                character: String.fromCodePoint(codePoint)\n                            });\n                        }\n                    }\n                });\n                if (mandatoryDigits > 0) {\n                    format.primary = formats.DECIMAL;\n                    // TODO validate decimal-digit-pattern\n\n                    // the decimal digit family (codepoint offset)\n                    format.zeroCode = zeroCode;\n                    // the number of mandatory digits\n                    format.mandatoryDigits = mandatoryDigits;\n                    // the number of optional digits\n                    format.optionalDigits = optionalDigits;\n                    // grouping separator template\n                    // are the grouping-separator-signs 'regular'?\n                    const regularRepeat = function (separators) {\n                        // are the grouping positions regular? i.e. same interval between each of them\n                        // is there at least one separator?\n                        if (separators.length === 0) {\n                            return 0;\n                        }\n                        // are all the characters the same?\n                        const sepChar = separators[0].character;\n                        for (let ii = 1; ii < separators.length; ii++) {\n                            if (separators[ii].character !== sepChar) {\n                                return 0;\n                            }\n                        }\n                        // are they equally spaced?\n                        const indexes = separators.map(separator => separator.position);\n                        const gcd = function (a, b) {\n                            return b === 0 ? a : gcd(b, a % b);\n                        };\n                        // find the greatest common divisor of all the positions\n                        const factor = indexes.reduce(gcd);\n                        // is every position separated by this divisor? If so, it's regular\n                        for (let index = 1; index <= indexes.length; index++) {\n                            if (indexes.indexOf(index * factor) === -1) {\n                                return 0;\n                            }\n                        }\n                        return factor;\n                    };\n\n                    const regular = regularRepeat(groupingSeparators);\n                    if (regular > 0) {\n                        format.regular = true;\n                        format.groupingSeparators = {\n                            position: regular,\n                            character: groupingSeparators[0].character\n                        };\n                    } else {\n                        format.regular = false;\n                        format.groupingSeparators = groupingSeparators;\n                    }\n\n                } else {\n                    // this is a 'numbering sequence' which the spec says is implementation-defined\n                    // this implementation doesn't support any numbering sequences at the moment.\n                    format.primary = formats.SEQUENCE;\n                    format.token = primaryFormat;\n                }\n            }\n        }\n\n        return format;\n    }\n\n    const defaultPresentationModifiers = {\n        Y: '1', M: '1', D: '1', d: '1', F: 'n', W: '1', w: '1', X: '1', x: '1', H: '1', h: '1',\n        P: 'n', m: '01', s: '01', f: '1', Z: '01:01', z: '01:01', C: 'n', E: 'n'\n    };\n\n    // \u00A79.8.4.1 the format specifier is an array of string literals and variable markers\n    /**\n     * analyse the date-time picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, parts: Array}} - the analysed string\n     */\n    function analyseDateTimePicture(picture) {\n        var spec = [];\n        const format = {\n            type: 'datetime',\n            parts: spec\n        };\n        const addLiteral = function (start, end) {\n            if (end > start) {\n                let literal = picture.substring(start, end);\n                // replace any doubled ]] with single ]\n                // what if there are instances of single ']' ? - the spec doesn't say\n                literal = literal.split(']]').join(']');\n                spec.push({type: 'literal', value: literal});\n            }\n        };\n\n        var start = 0, pos = 0;\n        while (pos < picture.length) {\n            if (picture.charAt(pos) === '[') {\n                // check it's not a doubled [[\n                if (picture.charAt(pos + 1) === '[') {\n                    // literal [\n                    addLiteral(start, pos);\n                    spec.push({type: 'literal', value: '['});\n                    pos += 2;\n                    start = pos;\n                    continue;\n                }\n                // start of variable marker\n                // push the string literal (if there is one) onto the array\n                addLiteral(start, pos);\n                start = pos;\n                // search forward to closing ]\n                pos = picture.indexOf(']', start);\n                // TODO handle error case if pos === -1\n                if(pos === -1) {\n                    // error - no closing bracket\n                    throw {\n                        code: 'D3135'\n                    };\n                }\n                let marker = picture.substring(start + 1, pos);\n                // whitespace within a variable marker is ignored (i.e. remove it)\n                marker = marker.split(/\\s+/).join('');\n                var def = {\n                    type: 'marker',\n                    component: marker.charAt(0)  // 1. The component specifier is always present and is always a single letter.\n                };\n                var comma = marker.lastIndexOf(','); // 2. The width modifier may be recognized by the presence of a comma\n                var presMod; // the presentation modifiers\n                if (comma !== -1) {\n                    // \u00A79.8.4.2 The Width Modifier\n                    const widthMod = marker.substring(comma + 1);\n                    const dash = widthMod.indexOf('-');\n                    let min, max;\n                    const parseWidth = function (wm) {\n                        if (typeof wm === 'undefined' || wm === '*') {\n                            return undefined;\n                        } else {\n                            // TODO validate wm is an unsigned int\n                            return parseInt(wm);\n                        }\n                    };\n                    if (dash === -1) {\n                        min = widthMod;\n                    } else {\n                        min = widthMod.substring(0, dash);\n                        max = widthMod.substring(dash + 1);\n                    }\n                    const widthDef = {\n                        min: parseWidth(min),\n                        max: parseWidth(max)\n                    };\n                    def.width = widthDef;\n                    presMod = marker.substring(1, comma);\n                } else {\n                    presMod = marker.substring(1);\n                }\n                if (presMod.length === 1) {\n                    def.presentation1 = presMod; // first presentation modifier\n                    //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture\n                } else if (presMod.length > 1) {\n                    var lastChar = presMod.charAt(presMod.length - 1);\n                    if ('atco'.indexOf(lastChar) !== -1) {\n                        def.presentation2 = lastChar;\n                        if (lastChar === 'o') {\n                            def.ordinal = true;\n                        }\n                        // 'c' means 'cardinal' and is the default (i.e. not 'ordinal')\n                        // 'a' & 't' are ignored (not sure of their relevance to English numbering)\n                        def.presentation1 = presMod.substring(0, presMod.length - 1);\n                    } else {\n                        def.presentation1 = presMod;\n                        //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture,\n                        // doesn't use ] as grouping separator, and if grouping separator is , then must have width modifier\n                    }\n                } else {\n                    // no presentation modifier specified - apply the default;\n                    def.presentation1 = defaultPresentationModifiers[def.component];\n                }\n                if (typeof def.presentation1 === 'undefined') {\n                    // unknown component specifier\n                    throw {\n                        code: 'D3132',\n                        value: def.component\n                    };\n                }\n                if (def.presentation1[0] === 'n') {\n                    def.names = tcase.LOWER;\n                } else if (def.presentation1[0] === 'N') {\n                    if (def.presentation1[1] === 'n') {\n                        def.names = tcase.TITLE;\n                    } else {\n                        def.names = tcase.UPPER;\n                    }\n                } else if ('YMDdFWwXxHhmsf'.indexOf(def.component) !== -1) {\n                    var integerPattern = def.presentation1;\n                    if (def.presentation2) {\n                        integerPattern += ';' + def.presentation2;\n                    }\n                    def.integerFormat = analyseIntegerPicture(integerPattern);\n                    if (def.width && def.width.min !== undefined) {\n                        if (def.integerFormat.mandatoryDigits < def.width.min) {\n                            def.integerFormat.mandatoryDigits = def.width.min;\n                        }\n                    }\n                    if (def.component === 'Y') {\n                        // \u00A79.8.4.4\n                        def.n = -1;\n                        if (def.width && def.width.max !== undefined) {\n                            def.n = def.width.max;\n                            def.integerFormat.mandatoryDigits = def.n;\n                        } else {\n                            var w = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;\n                            if (w >= 2) {\n                                def.n = w;\n                            }\n                        }\n                    }\n                    // if the previous part is also an integer with no intervening markup, then its width for parsing must be precisely defined\n                    const previousPart = spec[spec.length - 1];\n                    if (previousPart && previousPart.integerFormat) {\n                        previousPart.integerFormat.parseWidth = previousPart.integerFormat.mandatoryDigits;\n                    }\n                }\n                if (def.component === 'Z' || def.component === 'z') {\n                    def.integerFormat = analyseIntegerPicture(def.presentation1);\n                }\n                spec.push(def);\n                start = pos + 1;\n            }\n            pos++;\n        }\n        addLiteral(start, pos);\n        return format;\n    }\n\n    const days = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n    const millisInADay = 1000 * 60 * 60 * 24;\n\n    const startOfFirstWeek = function (ym) {\n        // ISO 8601 defines the first week of the year to be the week that contains the first Thursday\n        // XPath F&O extends this same definition for the first week of a month\n        // the week starts on a Monday - calculate the millis for the start of the first week\n        // millis for given 1st Jan of that year (at 00:00 UTC)\n        const jan1 = Date.UTC(ym.year, ym.month);\n        var dayOfJan1 = (new Date(jan1)).getUTCDay();\n        if (dayOfJan1 === 0) {\n            dayOfJan1 = 7;\n        }\n        // if Jan 1 is Fri, Sat or Sun, then add the number of days (in millis) to jan1 to get the start of week 1\n        return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;\n    };\n\n    const yearMonth = function (year, month) {\n        return {\n            year: year,\n            month: month,\n            nextMonth: function () {\n                return (month === 11) ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);\n            },\n            previousMonth: function () {\n                return (month === 0) ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);\n            },\n            nextYear: function () {\n                return yearMonth(year + 1, month);\n            },\n            previousYear: function () {\n                return yearMonth(year - 1, month);\n            }\n        };\n    };\n\n    const deltaWeeks = function (start, end) {\n        return (end - start) / (millisInADay * 7) + 1;\n    };\n\n    const getDateTimeFragment = (date, component) => {\n        let componentValue;\n        switch (component) {\n            case 'Y': // year\n                componentValue = date.getUTCFullYear();\n                break;\n            case 'M': // month in year\n                componentValue = date.getUTCMonth() + 1;\n                break;\n            case 'D': // day in month\n                componentValue = date.getUTCDate();\n                break;\n            case 'd': { // day in year\n                // millis for given date (at 00:00 UTC)\n                const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(date.getUTCFullYear(), 0);\n                componentValue = (today - firstJan) / millisInADay + 1;\n                break;\n            }\n            case 'F': // day of week\n                componentValue = date.getUTCDay();\n                if (componentValue === 0) {\n                    // ISO 8601 defines days 1-7: Mon-Sun\n                    componentValue = 7;\n                }\n                break;\n            case 'W': { // week in year\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfWeek1 = startOfFirstWeek(thisYear);\n                const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 52) {\n                    // might be first week of the following year\n                    const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());\n                    if (today >= startOfFollowingYear) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous year\n                    const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());\n                    week = deltaWeeks(startOfPreviousYear, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'w': { // week in month\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfWeek1 = startOfFirstWeek(thisMonth);\n                const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 4) {\n                    // might be first week of the following month\n                    const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());\n                    if (today >= startOfFollowingMonth) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous month\n                    const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());\n                    week = deltaWeeks(startOfPreviousMonth, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'X': { // ISO week-numbering year\n                // Extension: The F&O spec says nothing about how to access the year associated with the week-of-the-year\n                // e.g. Sat 1 Jan 2005 is in the 53rd week of 2004.\n                // The 'W' component specifier gives 53, but 'Y' will give 2005.\n                // I propose to add 'X' as the component specifier to give the ISO week-numbering year (2004 in this example)\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfISOYear = startOfFirstWeek(thisYear);\n                const endOfISOYear = startOfFirstWeek(thisYear.nextYear());\n                const now = date.getTime();\n                if (now < startOfISOYear) {\n                    componentValue = thisYear.year - 1;\n                } else if (now >= endOfISOYear) {\n                    componentValue = thisYear.year + 1;\n                } else {\n                    componentValue = thisYear.year;\n                }\n                break;\n            }\n            case 'x': { // ISO week-numbering month\n                // Extension: The F&O spec says nothing about how to access the month associated with the week-of-the-month\n                // e.g. Sat 1 Jan 2005 is in the 5th week of December 2004.\n                // The 'w' component specifier gives 5, but 'W' will give January and 'Y' will give 2005.\n                // I propose to add 'x' as the component specifier to give the 'week-numbering' month (December in this example)\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfISOMonth = startOfFirstWeek(thisMonth);\n                const nextMonth = thisMonth.nextMonth();\n                const endOfISOMonth = startOfFirstWeek(nextMonth);\n                const now = date.getTime();\n                if (now < startOfISOMonth) {\n                    componentValue = thisMonth.previousMonth().month + 1;\n                } else if (now >= endOfISOMonth) {\n                    componentValue = nextMonth.month + 1;\n                } else {\n                    componentValue = thisMonth.month + 1;\n                }\n                break;\n            }\n            case 'H': // hour in day (24 hours)\n                componentValue = date.getUTCHours();\n                break;\n            case 'h': // hour in half-day (12 hours)\n                componentValue = date.getUTCHours();\n                componentValue = componentValue % 12;\n                if (componentValue === 0) {\n                    componentValue = 12;\n                }\n                break;\n            case 'P': // am/pm marker\n                componentValue = date.getUTCHours() >= 12 ? 'pm' : 'am';\n                break;\n            case 'm': // minute in hour\n                componentValue = date.getUTCMinutes();\n                break;\n            case 's': // second in minute\n                componentValue = date.getUTCSeconds();\n                break;\n            case 'f': // fractional seconds\n                componentValue = date.getUTCMilliseconds();\n                break;\n            case 'Z': // timezone\n            case 'z':\n                // since the date object is constructed from epoch millis, the TZ component is always be UTC.\n                break;\n            case 'C': // calendar name\n                componentValue = 'ISO';\n                break;\n            case 'E': // era\n                componentValue = 'ISO';\n                break;\n        }\n        return componentValue;\n    };\n\n    let iso8601Spec = null;\n\n    /**\n     * formats the date/time as specified by the XPath fn:format-dateTime function\n     * @param {number} millis - the timestamp to be formatted, in millis since the epoch\n     * @param {string} picture - the picture string that specifies the format\n     * @param {string} timezone - the timezone to use\n     * @returns {string} - the formatted timestamp\n     */\n    function formatDateTime(millis, picture, timezone) {\n        var offsetHours = 0;\n        var offsetMinutes = 0;\n\n        if (typeof timezone !== 'undefined') {\n            // parse the hour and minute offsets\n            // assume for now the format supplied is +hhmm\n            const offset = parseInt(timezone);\n            offsetHours = Math.floor(offset / 100);\n            offsetMinutes = offset % 100;\n        }\n\n        var formatComponent = function (date, markerSpec) {\n            var componentValue = getDateTimeFragment(date, markerSpec.component);\n\n            // \u00A79.8.4.3 Formatting Integer-Valued Date/Time Components\n            if ('YMDdFWwXxHhms'.indexOf(markerSpec.component) !== -1) {\n                if (markerSpec.component === 'Y') {\n                    // \u00A79.8.4.4 Formatting the Year Component\n                    if (markerSpec.n !== -1) {\n                        componentValue = componentValue % Math.pow(10, markerSpec.n);\n                    }\n                }\n                if (markerSpec.names) {\n                    if (markerSpec.component === 'M' || markerSpec.component === 'x') {\n                        componentValue = months[componentValue - 1];\n                    } else if (markerSpec.component === 'F') {\n                        componentValue = days[componentValue];\n                    } else {\n                        throw {\n                            code: 'D3133',\n                            value: markerSpec.component\n                        };\n                    }\n                    if (markerSpec.names === tcase.UPPER) {\n                        componentValue = componentValue.toUpperCase();\n                    } else if (markerSpec.names === tcase.LOWER) {\n                        componentValue = componentValue.toLowerCase();\n                    }\n                    if (markerSpec.width && componentValue.length > markerSpec.width.max) {\n                        componentValue = componentValue.substring(0, markerSpec.width.max);\n                    }\n                } else {\n                    componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n                }\n            } else if (markerSpec.component === 'f') {\n                // TODO \u00A79.8.4.5 Formatting Fractional Seconds\n                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n            } else if (markerSpec.component === 'Z' || markerSpec.component === 'z') {\n                // \u00A79.8.4.6 Formatting timezones\n                const offset = offsetHours * 100 + offsetMinutes;\n                if (markerSpec.integerFormat.regular) {\n                    componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                } else {\n                    const numDigits = markerSpec.integerFormat.mandatoryDigits;\n                    if (numDigits === 1 || numDigits === 2) {\n                        componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);\n                        if (offsetMinutes !== 0) {\n                            componentValue += ':' + formatInteger(offsetMinutes, '00');\n                        }\n                    } else if (numDigits === 3 || numDigits === 4) {\n                        componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                    } else {\n                        throw {\n                            code: 'D3134',\n                            value: numDigits\n                        };\n                    }\n                }\n                if (offset >= 0) {\n                    componentValue = '+' + componentValue;\n                }\n                if (markerSpec.component === 'z') {\n                    componentValue = 'GMT' + componentValue;\n                }\n                if (offset === 0 && markerSpec.presentation2 === 't') {\n                    componentValue = 'Z';\n                }\n            } else if (markerSpec.component === 'P') {\n                // \u00A79.8.4.7 Formatting Other Components\n                // Formatting P for am/pm\n                // getDateTimeFragment() always returns am/pm lower case so check for UPPER here\n                if (markerSpec.names === tcase.UPPER) {\n                    componentValue = componentValue.toUpperCase();\n                }\n            }\n            return componentValue;\n        };\n\n        let formatSpec;\n        if(typeof picture === 'undefined') {\n            // default to ISO 8601 format\n            if (iso8601Spec === null) {\n                iso8601Spec = analyseDateTimePicture('[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]');\n            }\n            formatSpec = iso8601Spec;\n        } else {\n            formatSpec = analyseDateTimePicture(picture);\n        }\n\n        const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1000;\n        const dateTime = new Date(millis + offsetMillis);\n\n        let result = '';\n        formatSpec.parts.forEach(function (part) {\n            if (part.type === 'literal') {\n                result += part.value;\n            } else {\n                result += formatComponent(dateTime, part);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Generate a regex to parse integers or timestamps\n     * @param {object} formatSpec - object representing the format\n     * @returns {object} - regex\n     */\n    function generateRegex(formatSpec) {\n        var matcher = {};\n        if (formatSpec.type === 'datetime') {\n            matcher.type = 'datetime';\n            matcher.parts = formatSpec.parts.map(function (part) {\n                var res = {};\n                if (part.type === 'literal') {\n                    res.regex = part.value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                } else if (part.component === 'Z' || part.component === 'z') {\n                    // timezone\n                    let separator;\n                    if (!Array.isArray(part.integerFormat.groupingSeparators)) {\n                        separator = part.integerFormat.groupingSeparators;\n                    }\n                    res.regex = '';\n                    if (part.component === 'z') {\n                        res.regex = 'GMT';\n                    }\n                    res.regex += '[-+][0-9]+';\n                    if (separator) {\n                        res.regex += separator.character + '[0-9]+';\n                    }\n                    res.parse = function(value) {\n                        if (part.component === 'z') {\n                            value = value.substring(3); // remove the leading GMT\n                        }\n                        let offsetHours = 0, offsetMinutes = 0;\n                        if (separator) {\n                            offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));\n                            offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));\n                        } else {\n                            // depends on number of digits\n                            const numdigits = value.length - 1;\n                            if (numdigits <= 2) {\n                                // just hour offset\n                                offsetHours = Number.parseInt(value);\n                            } else {\n                                offsetHours = Number.parseInt(value.substring(0, 3));\n                                offsetMinutes = Number.parseInt(value.substring(3));\n                            }\n                        }\n                        return offsetHours * 60 + offsetMinutes;\n                    };\n                } else if (part.integerFormat) {\n                    res = generateRegex(part.integerFormat);\n                } else {\n                    // must be a month or day name\n                    res.regex = '[a-zA-Z]+';\n                    var lookup = {};\n                    if (part.component === 'M' || part.component === 'x') {\n                        // months\n                        months.forEach(function (name, index) {\n                            if (part.width && part.width.max) {\n                                lookup[name.substring(0, part.width.max)] = index + 1;\n                            } else {\n                                lookup[name] = index + 1;\n                            }\n                        });\n                    } else if (part.component === 'F') {\n                        // days\n                        days.forEach(function (name, index) {\n                            if (index > 0) {\n                                if (part.width && part.width.max) {\n                                    lookup[name.substring(0, part.width.max)] = index;\n                                } else {\n                                    lookup[name] = index;\n                                }\n                            }\n                        });\n                    } else if (part.component === 'P') {\n                        lookup = {'am': 0, 'AM': 0, 'pm': 1, 'PM': 1};\n                    } else {\n                        // unsupported 'name' option for this component\n                        throw {\n                            code: 'D3133',\n                            value: part.component\n                        };\n                    }\n                    res.parse = function (value) {\n                        return lookup[value];\n                    };\n                }\n                res.component = part.component;\n                return res;\n            });\n        } else { // type === 'integer'\n            matcher.type = 'integer';\n            const isUpper = formatSpec.case === tcase.UPPER;\n\n            switch (formatSpec.primary) {\n                case formats.LETTERS:\n                    matcher.regex = isUpper ? '[A-Z]+' : '[a-z]+';\n                    matcher.parse = function (value) {\n                        return lettersToDecimal(value, isUpper ? 'A' : 'a');\n                    };\n                    break;\n                case formats.ROMAN:\n                    matcher.regex = isUpper ? '[MDCLXVI]+' : '[mdclxvi]+';\n                    matcher.parse = function (value) {\n                        return romanToDecimal(isUpper ? value : value.toUpperCase());\n                    };\n                    break;\n                case formats.WORDS:\n                    matcher.regex = '(?:' + Object.keys(wordValues).concat('and', '[\\\\-, ]').join('|') + ')+';\n                    matcher.parse = function (value) {\n                        return wordsToNumber(value.toLowerCase());\n                    };\n                    break;\n                case formats.DECIMAL:\n                    matcher.regex = '[0-9]';\n                    if (formatSpec.parseWidth) {\n                        matcher.regex += `{${formatSpec.parseWidth}}`;\n                    } else {\n                        matcher.regex += '+';\n                    }\n                    if (formatSpec.ordinal) {\n                        // ordinals\n                        matcher.regex += '(?:th|st|nd|rd)';\n                    }\n                    matcher.parse = function (value) {\n                        let digits = value;\n                        if (formatSpec.ordinal) {\n                            // strip off the suffix\n                            digits = value.substring(0, value.length - 2);\n                        }\n                        // strip out the separators\n                        if (formatSpec.regular) {\n                            digits = digits.split(',').join('');\n                        } else {\n                            formatSpec.groupingSeparators.forEach(sep => {\n                                digits = digits.split(sep.character).join('');\n                            });\n                        }\n                        if (formatSpec.zeroCode !== 0x30) {\n                            // apply offset\n                            digits = digits.split('').map(char => String.fromCodePoint(char.codePointAt(0) - formatSpec.zeroCode + 0x30)).join('');\n                        }\n                        return parseInt(digits);\n                    };\n                    break;\n                case formats.SEQUENCE:\n                    throw {\n                        code: 'D3130',\n                        value: formatSpec.token\n                    };\n            }\n\n        }\n        return matcher;\n    }\n\n    /**\n     * parse a string containing an integer as specified by the picture string\n     * @param {string} value - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed number\n     */\n    function parseInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        const formatSpec = analyseIntegerPicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        //const fullRegex = '^' + matchSpec.regex + '$';\n        //const matcher = new RegExp(fullRegex);\n        // TODO validate input based on the matcher regex\n        const result = matchSpec.parse(value);\n        return result;\n    }\n\n    /**\n     * parse a string containing a timestamp as specified by the picture string\n     * @param {string} timestamp - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed timestamp in millis since the epoch\n     */\n    function parseDateTime(timestamp, picture) {\n        const formatSpec = analyseDateTimePicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        const fullRegex = '^' + matchSpec.parts.map(part => '(' + part.regex + ')').join('') + '$';\n\n        const matcher = new RegExp(fullRegex, 'i'); // TODO can cache this against the picture\n        var info = matcher.exec(timestamp);\n        if (info !== null) {\n            // validate what we've just parsed - do we have enough information to create a timestamp?\n            // rules:\n            // The date is specified by one of:\n            //    {Y, M, D}    (dateA)\n            // or {Y, d}       (dateB)\n            // or {Y, x, w, F} (dateC)\n            // or {X, W, F}    (dateD)\n            // The time is specified by one of:\n            //    {H, m, s, f}    (timeA)\n            // or {P, h, m, s, f} (timeB)\n            // All sets can have an optional Z\n            // To create a timestamp (epoch millis) we need both date and time, but we can default missing\n            // information according to the following rules:\n            // - line up one combination of the above from date, and one from time, most significant value (MSV) to least significant (LSV\n            // - for the values that have been captured, if there are any gaps between MSV and LSV, then throw an error\n            //     (e.g.) if hour and seconds, but not minutes is given - throw\n            //     (e.g.) if month, hour and minutes, but not day-of-month is given - throw\n            // - anything right of the LSV should be defaulted to zero\n            //     (e.g.) if hour and minutes given, default seconds and fractional seconds to zero\n            //     (e.g.) if date only given, default the time to 0:00:00.000 (midnight)\n            // - anything left of the MSV should be defaulted to the value of that component returned by $now()\n            //     (e.g.) if time only given, default the date to today\n            //     (e.g.) if month and date given, default to this year (and midnight, by previous rule)\n            //   -- default values for X, x, W, w, F will be derived from the values returned by $now()\n\n            // implement the above rules\n            // determine which of the above date/time combinations we have by using bit masks\n\n            //        Y X M x W w d D F P H h m s f Z\n            // dateA  1 0 1 0 0 0 0 1 ?                     0 - must not appear\n            // dateB  1 0 0 0 0 0 1 0 ?                     1 - can appear - relevant\n            // dateC  0 1 0 1 0 1 0 0 1                     ? - can appear - ignored\n            // dateD  0 1 0 0 1 0 0 0 1\n            // timeA                    0 1 0 1 1 1\n            // timeB                    1 0 1 1 1 1\n\n            // create bitmasks based on the above\n            //    date mask             YXMxWwdD\n            const dmA = 161;  // binary 10100001\n            const dmB = 130;  // binary 10000010\n            const dmC = 84;   // binary 01010100\n            const dmD = 72;   // binary 01001000\n            //    time mask             PHhmsf\n            const tmA = 23;   // binary 010111\n            const tmB = 47;   // binary 101111\n\n            const components = {};\n            for (let i = 1; i < info.length; i++) {\n                const mpart = matchSpec.parts[i - 1];\n                if (mpart.parse) {\n                    components[mpart.component] = mpart.parse(info[i]);\n                }\n            }\n\n            if(Object.getOwnPropertyNames(components).length === 0) {\n                // nothing specified\n                return undefined;\n            }\n\n            let mask = 0;\n\n            const shift = bit => {\n                mask <<= 1;\n                mask += bit ? 1 : 0;\n            };\n\n            const isType = type => {\n                // shouldn't match any 0's, must match at least one 1\n                return !(~type & mask) && !!(type & mask);\n            };\n\n            'YXMxWwdD'.split('').forEach(part => shift(components[part]));\n\n            const dateA = isType(dmA);\n            const dateB = !dateA && isType(dmB);\n            const dateC = isType(dmC);\n            const dateD = !dateC && isType(dmD);\n\n            mask = 0;\n            'PHhmsf'.split('').forEach(part => shift(components[part]));\n\n            const timeA = isType(tmA);\n            const timeB = !timeA && isType(tmB);\n\n            // should only be zero or one date type and zero or one time type\n\n            const dateComps = dateB ? 'YD' : dateC ? 'XxwF' : dateD? 'XWF' : 'YMD';\n            const timeComps = timeB ? 'Phmsf' : 'Hmsf';\n\n            const comps = dateComps + timeComps;\n\n            // step through the candidate parts from most significant to least significant\n            // default the most significant unspecified parts to current timestamp component\n            // default the least significant unspecified parts to zero\n            // if any gaps in between the specified parts, throw an error\n\n            const now = this.environment.timestamp; // must get the fixed timestamp from jsonata\n\n            let startSpecified = false;\n            let endSpecified = false;\n            comps.split('').forEach(part => {\n                if(typeof components[part] === 'undefined') {\n                    if(startSpecified) {\n                        // past the specified block - default to zero\n                        components[part] = ('MDd'.indexOf(part) !== -1) ? 1 : 0;\n                        endSpecified = true;\n                    } else {\n                        // haven't hit the specified block yet, default to current timestamp\n                        components[part] = getDateTimeFragment(now, part);\n                    }\n                } else {\n                    startSpecified = true;\n                    if(endSpecified) {\n                        throw {\n                            code: 'D3136'\n                        };\n                    }\n                }\n            });\n\n            // validate and fill in components\n            if (components.M > 0) {\n                components.M -= 1;  // Date.UTC requires a zero-indexed month\n            } else {\n                components.M = 0; // default to January\n            }\n            if (dateB) {\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(components.Y, 0);\n                const offsetMillis = (components.d - 1) * 1000 * 60 * 60 * 24;\n                const derivedDate = new Date(firstJan + offsetMillis);\n                components.M = derivedDate.getUTCMonth();\n                components.D = derivedDate.getUTCDate();\n            }\n            if (dateC) {\n                // TODO implement this\n                // parsing this format not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (dateD) {\n                // TODO implement this\n                // parsing this format (ISO week date) not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (timeB) {\n                // 12hr to 24hr\n                components.H = components.h === 12 ? 0 : components.h;\n                if (components.P === 1) {\n                    components.H += 12;\n                }\n            }\n\n            var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);\n            if(components.Z || components.z) {\n                // adjust for timezone\n                millis -= (components.Z || components.z) * 60 * 1000;\n            }\n            return millis;\n        }\n    }\n\n    // Regular expression to match an ISO 8601 formatted timestamp\n    var iso8601regex = new RegExp('^\\\\d{4}(-[01]\\\\d)*(-[0-3]\\\\d)*(T[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d)*(\\\\.\\\\d+)?([+-][0-2]\\\\d:?[0-5]\\\\d|Z)?$');\n\n    /**\n     * Converts an ISO 8601 timestamp to milliseconds since the epoch\n     *\n     * @param {string} timestamp - the timestamp to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @returns {Number} - milliseconds since the epoch\n     */\n    function toMillis(timestamp, picture) {\n        // undefined inputs always return undefined\n        if(typeof timestamp === 'undefined') {\n            return undefined;\n        }\n\n        if(typeof picture === 'undefined') {\n            if (!iso8601regex.test(timestamp)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3110\",\n                    value: timestamp\n                };\n            }\n\n            return Date.parse(timestamp);\n        } else {\n            return parseDateTime.call(this, timestamp, picture);\n        }\n    }\n\n    /**\n     * Converts milliseconds since the epoch to an ISO 8601 timestamp\n     * @param {Number} millis - milliseconds since the epoch to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @param {string} [timezone] - the timezone to format the timestamp in (defaults to UTC)\n     * @returns {String} - the formatted timestamp\n     */\n    function fromMillis(millis, picture, timezone) {\n        // undefined inputs always return undefined\n        if(typeof millis === 'undefined') {\n            return undefined;\n        }\n\n        return formatDateTime.call(this, millis, picture, timezone);\n    }\n\n    return {\n        formatInteger, parseInteger, fromMillis, toMillis\n    };\n})();\n\nmodule.exports = dateTime;\n\n},{\"./utils\":6}],2:[function(require,module,exports){\n(function (global){(function (){\n/**\n * \u00A9 Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst functions = (() => {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var deepEquals = utils.isDeepEqual;\n    var stringToArray = utils.stringToArray;\n\n    /**\n     * Sum function\n     * @param {Object} args - Arguments\n     * @returns {number} Total value of arguments\n     */\n    function sum(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total;\n    }\n\n    /**\n     * Count function\n     * @param {Object} args - Arguments\n     * @returns {number} Number of elements in the array\n     */\n    function count(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return 0;\n        }\n\n        return args.length;\n    }\n\n    /**\n     * Max function\n     * @param {Object} args - Arguments\n     * @returns {number} Max element in the array\n     */\n    function max(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.max.apply(Math, args);\n    }\n\n    /**\n     * Min function\n     * @param {Object} args - Arguments\n     * @returns {number} Min element in the array\n     */\n    function min(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.min.apply(Math, args);\n    }\n\n    /**\n     * Average function\n     * @param {Object} args - Arguments\n     * @returns {number} Average element in the array\n     */\n    function average(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total / args.length;\n    }\n\n    /**\n     * Stringify arguments\n     * @param {Object} arg - Arguments\n     * @param {boolean} [prettify] - Pretty print the result\n     * @returns {String} String from arguments\n     */\n    function string(arg, prettify = false) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var str;\n\n        if (typeof arg === 'string') {\n            // already a string\n            str = arg;\n        } else if (isFunction(arg)) {\n            // functions (built-in and lambda convert to empty string\n            str = '';\n        } else if (typeof arg === 'number' && !isFinite(arg)) {\n            throw {\n                code: \"D3001\",\n                value: arg,\n                stack: (new Error()).stack\n            };\n        } else {\n            var space = prettify ? 2 : 0;\n            if(Array.isArray(arg) && arg.outerWrapper) {\n                arg = arg[0];\n            }\n            str = JSON.stringify(arg, function (key, val) {\n                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(15)) :\n                    (val && isFunction(val)) ? '' : val;\n            }, space);\n        }\n        return str;\n    }\n\n    /**\n     * Create substring based on character number and length\n     * @param {String} str - String to evaluate\n     * @param {Integer} start - Character number to start substring\n     * @param {Integer} [length] - Number of characters in substring\n     * @returns {string|*} Substring\n     */\n    function substring(str, start, length) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var strArray = stringToArray(str);\n        var strLength = strArray.length;\n\n        if (strLength + start < 0) {\n            start = 0;\n        }\n\n        if (typeof length !== 'undefined') {\n            if (length <= 0) {\n                return '';\n            }\n            var end = start >= 0 ? start + length : strLength + start + length;\n            return strArray.slice(start, end).join('');\n        }\n\n        return strArray.slice(start).join('');\n    }\n\n    /**\n     * Create substring up until a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringBefore(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(0, pos);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Create substring after a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringAfter(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(pos + chars.length);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Lowercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Lowercase string\n     */\n    function lowercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toLowerCase();\n    }\n\n    /**\n     * Uppercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Uppercase string\n     */\n    function uppercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toUpperCase();\n    }\n\n    /**\n     * length of a string\n     * @param {String} str - string\n     * @returns {Number} The number of characters in the string\n     */\n    function length(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return stringToArray(str).length;\n    }\n\n    /**\n     * Normalize and trim whitespace within a string\n     * @param {string} str - string to be trimmed\n     * @returns {string} - trimmed string\n     */\n    function trim(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // normalize whitespace\n        var result = str.replace(/[ \\t\\n\\r]+/gm, ' ');\n        if (result.charAt(0) === ' ') {\n            // strip leading space\n            result = result.substring(1);\n        }\n        if (result.charAt(result.length - 1) === ' ') {\n            // strip trailing space\n            result = result.substring(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Pad a string to a minimum width by adding characters to the start or end\n     * @param {string} str - string to be padded\n     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left\n     * @param {string} [char] - the pad character(s); defaults to ' '\n     * @returns {string} - padded string\n     */\n    function pad(str, width, char) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof char === 'undefined' || char.length === 0) {\n            char = ' ';\n        }\n\n        var result;\n        width = Math.trunc(width);\n        var padLength = Math.abs(width) - length(str);\n        if (padLength > 0) {\n            var padding = (new Array(padLength + 1)).join(char);\n            if (char.length > 1) {\n                padding = substring(padding, 0, padLength);\n            }\n            if (width > 0) {\n                result = str + padding;\n            } else {\n                result = padding + str;\n            }\n        } else {\n            result = str;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate the matcher function against the str arg\n     *\n     * @param {*} matcher - matching function (native or lambda)\n     * @param {string} str - the string to match against\n     * @returns {object} - structure that represents the match(es)\n     */\n    async function evaluateMatcher(matcher, str) {\n        var result = matcher.apply(this, [str]); // eslint-disable-line no-useless-call\n        if(isPromise(result)) {\n            result = await result;\n        }\n        if(result && !(typeof result.start === 'number' || result.end === 'number' || Array.isArray(result.groups) || isFunction(result.next))) {\n            // the matcher function didn't return the correct structure\n            throw {\n                code: \"T1010\",\n                stack: (new Error()).stack,\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Tests if the str contains the token\n     * @param {String} str - string to test\n     * @param {String} token - substring or regex to find\n     * @returns {Boolean} - true if str contains token\n     */\n    async function contains(str, token) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        if (typeof token === 'string') {\n            result = (str.indexOf(token) !== -1);\n        } else {\n            var matches = await evaluateMatcher(token, str);\n            result = (typeof matches !== 'undefined');\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} regex - the regex applied to the string\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function match(str, regex, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                stack: (new Error()).stack,\n                value: limit,\n                code: 'D3040',\n                index: 3\n            };\n        }\n\n        var result = createSequence();\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            var matches = await evaluateMatcher(regex, str);\n            if (typeof matches !== 'undefined') {\n                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                    result.push({\n                        match: matches.match,\n                        index: matches.start,\n                        groups: matches.groups\n                    });\n                    matches = await evaluateMatcher(matches.next);\n                    count++;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} pattern - the substring/regex applied to the string\n     * @param {String} replacement - text to replace the matched substrings\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function replace(str, pattern, replacement, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var self = this;\n\n        // pattern cannot be an empty string\n        if (pattern === '') {\n            throw {\n                code: \"D3010\",\n                stack: (new Error()).stack,\n                value: pattern,\n                index: 2\n            };\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3011\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 4\n            };\n        }\n\n        var replacer;\n        if (typeof replacement === 'string') {\n            replacer = function (regexMatch) {\n                var substitute = '';\n                // scan forward, copying the replacement text into the substitute string\n                // and replace any occurrence of $n with the values matched by the regex\n                var position = 0;\n                var index = replacement.indexOf('$', position);\n                while (index !== -1 && position < replacement.length) {\n                    substitute += replacement.substring(position, index);\n                    position = index + 1;\n                    var dollarVal = replacement.charAt(position);\n                    if (dollarVal === '$') {\n                        // literal $\n                        substitute += '$';\n                        position++;\n                    } else if (dollarVal === '0') {\n                        substitute += regexMatch.match;\n                        position++;\n                    } else {\n                        var maxDigits;\n                        if (regexMatch.groups.length === 0) {\n                            // no sub-matches; any $ followed by a digit will be replaced by an empty string\n                            maxDigits = 1;\n                        } else {\n                            // max number of digits to parse following the $\n                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;\n                        }\n                        index = parseInt(replacement.substring(position, position + maxDigits), 10);\n                        if (maxDigits > 1 && index > regexMatch.groups.length) {\n                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);\n                        }\n                        if (!isNaN(index)) {\n                            if (regexMatch.groups.length > 0) {\n                                var submatch = regexMatch.groups[index - 1];\n                                if (typeof submatch !== 'undefined') {\n                                    substitute += submatch;\n                                }\n                            }\n                            position += index.toString().length;\n                        } else {\n                            // not a capture group, treat the $ as literal\n                            substitute += '$';\n                        }\n                    }\n                    index = replacement.indexOf('$', position);\n                }\n                substitute += replacement.substring(position);\n                return substitute;\n            };\n        } else {\n            replacer = replacement;\n        }\n\n        var result = '';\n        var position = 0;\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            if (typeof pattern === 'string') {\n                var index = str.indexOf(pattern, position);\n                while (index !== -1 && (typeof limit === 'undefined' || count < limit)) {\n                    result += str.substring(position, index);\n                    result += replacement;\n                    position = index + pattern.length;\n                    count++;\n                    index = str.indexOf(pattern, position);\n                }\n                result += str.substring(position);\n            } else {\n                var matches = await evaluateMatcher(pattern, str);\n                if (typeof matches !== 'undefined') {\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result += str.substring(position, matches.start);\n                        var replacedWith = replacer.apply(self, [matches]);\n                        if (isPromise(replacedWith)) {\n                            replacedWith = await replacedWith;\n                        }\n                        // check replacedWith is a string\n                        if (typeof replacedWith === 'string') {\n                            result += replacedWith;\n                        } else {\n                            // not a string - throw error\n                            throw {\n                                code: \"D3012\",\n                                stack: (new Error()).stack,\n                                value: replacedWith\n                            };\n                        }\n                        position = matches.start + matches.match.length;\n                        count++;\n                        matches = await evaluateMatcher(matches.next);\n                    }\n                    result += str.substring(position);\n                } else {\n                    result = str;\n                }\n            }\n        } else {\n            result = str;\n        }\n\n        return result;\n    }\n\n    /**\n     * Base64 encode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64encode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n\n        var btoa = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.btoa :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'binary').toString('base64'); // eslint-disable-line new-cap\n            };\n        return btoa(str);\n    }\n\n    /**\n     * Base64 decode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64decode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n        var atob = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.atob :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'base64').toString('binary'); // eslint-disable-line new-cap\n            };\n        return atob(str);\n    }\n\n    /**\n     * Encode a string into a component for a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Encode a string into a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a component for a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Split a string into an array of substrings\n     * @param {String} str - string\n     * @param {String} separator - the token or regex that splits the string\n     * @param {Integer} [limit] - max number of substrings\n     * @returns {Array} The array of string\n     */\n    async function split(str, separator, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3020\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 3\n            };\n        }\n\n        var result = [];\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            if (typeof separator === 'string') {\n                result = str.split(separator, limit);\n            } else {\n                var count = 0;\n                var matches = await evaluateMatcher(separator, str);\n                if (typeof matches !== 'undefined') {\n                    var start = 0;\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result.push(str.substring(start, matches.start));\n                        start = matches.end;\n                        matches = await evaluateMatcher(matches.next);\n                        count++;\n                    }\n                    if (typeof limit === 'undefined' || count < limit) {\n                        result.push(str.substring(start));\n                    }\n                } else {\n                    result.push(str);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Join an array of strings\n     * @param {Array} strs - array of string\n     * @param {String} [separator] - the token that splits the string\n     * @returns {String} The concatenated string\n     */\n    function join(strs, separator) {\n        // undefined inputs always return undefined\n        if (typeof strs === 'undefined') {\n            return undefined;\n        }\n\n        // if separator is not specified, default to empty string\n        if (typeof separator === 'undefined') {\n            separator = \"\";\n        }\n\n        return strs.join(separator);\n    }\n\n    /**\n     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec\n     * @param {number} value - number to format\n     * @param {String} picture - picture string definition\n     * @param {Object} [options] - override locale defaults\n     * @returns {String} The formatted string\n     */\n    function formatNumber(value, picture, options) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        var defaults = {\n            \"decimal-separator\": \".\",\n            \"grouping-separator\": \",\",\n            \"exponent-separator\": \"e\",\n            \"infinity\": \"Infinity\",\n            \"minus-sign\": \"-\",\n            \"NaN\": \"NaN\",\n            \"percent\": \"%\",\n            \"per-mille\": \"\\u2030\",\n            \"zero-digit\": \"0\",\n            \"digit\": \"#\",\n            \"pattern-separator\": \";\"\n        };\n\n        // if `options` is specified, then its entries override defaults\n        var properties = defaults;\n        if (typeof options !== 'undefined') {\n            Object.keys(options).forEach(function (key) {\n                properties[key] = options[key];\n            });\n        }\n\n        var decimalDigitFamily = [];\n        var zeroCharCode = properties['zero-digit'].charCodeAt(0);\n        for (var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {\n            decimalDigitFamily.push(String.fromCharCode(ii));\n        }\n\n        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);\n\n        var subPictures = picture.split(properties['pattern-separator']);\n\n        if (subPictures.length > 2) {\n            throw {\n                code: 'D3080',\n                stack: (new Error()).stack\n            };\n        }\n\n        var splitParts = function (subpicture) {\n            var prefix = (function () {\n                var ch;\n                for (var ii = 0; ii < subpicture.length; ii++) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(0, ii);\n                    }\n                }\n            })();\n            var suffix = (function () {\n                var ch;\n                for (var ii = subpicture.length - 1; ii >= 0; ii--) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(ii + 1);\n                    }\n                }\n            })();\n            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);\n            var mantissaPart, exponentPart, integerPart, fractionalPart;\n            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);\n            if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {\n                mantissaPart = activePart;\n                exponentPart = undefined;\n            } else {\n                mantissaPart = activePart.substring(0, exponentPosition);\n                exponentPart = activePart.substring(exponentPosition + 1);\n            }\n            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);\n            if (decimalPosition === -1) {\n                integerPart = mantissaPart;\n                fractionalPart = suffix;\n            } else {\n                integerPart = mantissaPart.substring(0, decimalPosition);\n                fractionalPart = mantissaPart.substring(decimalPosition + 1);\n            }\n            return {\n                prefix: prefix,\n                suffix: suffix,\n                activePart: activePart,\n                mantissaPart: mantissaPart,\n                exponentPart: exponentPart,\n                integerPart: integerPart,\n                fractionalPart: fractionalPart,\n                subpicture: subpicture\n            };\n        };\n\n        // validate the picture string, F&O 4.7.3\n        var validate = function (parts) {\n            var error;\n            var ii;\n            var subpicture = parts.subpicture;\n            var decimalPos = subpicture.indexOf(properties['decimal-separator']);\n            if (decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {\n                error = 'D3081';\n            }\n            if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {\n                error = 'D3082';\n            }\n            if (subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {\n                error = 'D3083';\n            }\n            if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {\n                error = 'D3084';\n            }\n            var valid = false;\n            for (ii = 0; ii < parts.mantissaPart.length; ii++) {\n                var ch = parts.mantissaPart.charAt(ii);\n                if (decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                error = 'D3085';\n            }\n            var charTypes = parts.activePart.split('').map(function (char) {\n                return activeChars.indexOf(char) === -1 ? 'p' : 'a';\n            }).join('');\n            if (charTypes.indexOf('p') !== -1) {\n                error = 'D3086';\n            }\n            if (decimalPos !== -1) {\n                if (subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {\n                    error = 'D3087';\n                }\n            } else if (parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {\n                error = 'D3088';\n            }\n            if (subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {\n                error = 'D3089';\n            }\n            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3090';\n            }\n            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3091';\n            }\n            var exponentExists = (typeof parts.exponentPart === 'string');\n            if (exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {\n                error = 'D3092';\n            }\n            if (exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) === -1;\n            }).length > 0)) {\n                error = 'D3093';\n            }\n            if (error) {\n                throw {\n                    code: error,\n                    stack: (new Error()).stack\n                };\n            }\n        };\n\n        // analyse the picture string, F&O 4.7.4\n        var analyse = function (parts) {\n            var getGroupingPositions = function (part, toLeft) {\n                var positions = [];\n                var groupingPosition = part.indexOf(properties['grouping-separator']);\n                while (groupingPosition !== -1) {\n                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function (char) {\n                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n                    }).length;\n                    positions.push(charsToTheRight);\n                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);\n                }\n                return positions;\n            };\n            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);\n            var regular = function (indexes) {\n                // are the grouping positions regular? i.e. same interval between each of them\n                if (indexes.length === 0) {\n                    return 0;\n                }\n                var gcd = function (a, b) {\n                    return b === 0 ? a : gcd(b, a % b);\n                };\n                // find the greatest common divisor of all the positions\n                var factor = indexes.reduce(gcd);\n                // is every position separated by this divisor? If so, it's regular\n                for (var index = 1; index <= indexes.length; index++) {\n                    if (indexes.indexOf(index * factor) === -1) {\n                        return 0;\n                    }\n                }\n                return factor;\n            };\n\n            var regularGrouping = regular(integerPartGroupingPositions);\n            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);\n\n            var minimumIntegerPartSize = parts.integerPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var scalingFactor = minimumIntegerPartSize;\n\n            var fractionalPartArray = parts.fractionalPart.split('');\n            var minimumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var maximumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n            }).length;\n            var exponentPresent = typeof parts.exponentPart === 'string';\n            if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {\n                if (exponentPresent) {\n                    minimumFactionalPartSize = 1;\n                    maximumFactionalPartSize = 1;\n                } else {\n                    minimumIntegerPartSize = 1;\n                }\n            }\n            if (exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {\n                minimumIntegerPartSize = 1;\n            }\n            if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {\n                minimumFactionalPartSize = 1;\n            }\n            var minimumExponentSize = 0;\n            if (exponentPresent) {\n                minimumExponentSize = parts.exponentPart.split('').filter(function (char) {\n                    return decimalDigitFamily.indexOf(char) !== -1;\n                }).length;\n            }\n\n            return {\n                integerPartGroupingPositions: integerPartGroupingPositions,\n                regularGrouping: regularGrouping,\n                minimumIntegerPartSize: minimumIntegerPartSize,\n                scalingFactor: scalingFactor,\n                prefix: parts.prefix,\n                fractionalPartGroupingPositions: fractionalPartGroupingPositions,\n                minimumFactionalPartSize: minimumFactionalPartSize,\n                maximumFactionalPartSize: maximumFactionalPartSize,\n                minimumExponentSize: minimumExponentSize,\n                suffix: parts.suffix,\n                picture: parts.subpicture\n            };\n        };\n\n        var parts = subPictures.map(splitParts);\n        parts.forEach(validate);\n\n        var variables = parts.map(analyse);\n\n        var minus_sign = properties['minus-sign'];\n        var zero_digit = properties['zero-digit'];\n        var decimal_separator = properties['decimal-separator'];\n        var grouping_separator = properties['grouping-separator'];\n\n        if (variables.length === 1) {\n            variables.push(JSON.parse(JSON.stringify(variables[0])));\n            variables[1].prefix = minus_sign + variables[1].prefix;\n        }\n\n        // TODO cache the result of the analysis\n\n        // format the number\n        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON\n        var pic;\n        // bullet 2:\n        if (value >= 0) {\n            pic = variables[0];\n        } else {\n            pic = variables[1];\n        }\n        var adjustedNumber;\n        // bullet 3:\n        if (pic.picture.indexOf(properties.percent) !== -1) {\n            adjustedNumber = value * 100;\n        } else if (pic.picture.indexOf(properties['per-mille']) !== -1) {\n            adjustedNumber = value * 1000;\n        } else {\n            adjustedNumber = value;\n        }\n        // bullet 4:\n        // TODO: infinity - not sure we'd ever get this in JSON\n        // bullet 5:\n        var mantissa, exponent;\n        if (pic.minimumExponentSize === 0) {\n            mantissa = adjustedNumber;\n        } else {\n            // mantissa * 10^exponent = adjustedNumber\n            var maxMantissa = Math.pow(10, pic.scalingFactor);\n            var minMantissa = Math.pow(10, pic.scalingFactor - 1);\n            mantissa = adjustedNumber;\n            exponent = 0;\n            while (mantissa < minMantissa) {\n                mantissa *= 10;\n                exponent -= 1;\n            }\n            while (mantissa > maxMantissa) {\n                mantissa /= 10;\n                exponent += 1;\n            }\n        }\n        // bullet 6:\n        var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);\n        // bullet 7:\n        var makeString = function (value, dp) {\n            var str = Math.abs(value).toFixed(dp);\n            if (zero_digit !== '0') {\n                str = str.split('').map(function (digit) {\n                    if (digit >= '0' && digit <= '9') {\n                        return decimalDigitFamily[digit.charCodeAt(0) - 48];\n                    } else {\n                        return digit;\n                    }\n                }).join('');\n            }\n            return str;\n        };\n        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);\n        var decimalPos = stringValue.indexOf('.');\n        if (decimalPos === -1) {\n            stringValue = stringValue + decimal_separator;\n        } else {\n            stringValue = stringValue.replace('.', decimal_separator);\n        }\n        while (stringValue.charAt(0) === zero_digit) {\n            stringValue = stringValue.substring(1);\n        }\n        while (stringValue.charAt(stringValue.length - 1) === zero_digit) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullets 8 & 9:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        var padLeft = pic.minimumIntegerPartSize - decimalPos;\n        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);\n        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : '') + stringValue;\n        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : '');\n        decimalPos = stringValue.indexOf(decimal_separator);\n        // bullet 10:\n        if (pic.regularGrouping > 0) {\n            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);\n            for (var group = 1; group <= groupCount; group++) {\n                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');\n            }\n        } else {\n            pic.integerPartGroupingPositions.forEach(function (pos) {\n                stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join('');\n                decimalPos++;\n            });\n        }\n        // bullet 11:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        pic.fractionalPartGroupingPositions.forEach(function (pos) {\n            stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join('');\n        });\n        // bullet 12:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullet 13:\n        if (typeof exponent !== 'undefined') {\n            var stringExponent = makeString(exponent, 0);\n            padLeft = pic.minimumExponentSize - stringExponent.length;\n            if (padLeft > 0) {\n                stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;\n            }\n            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? minus_sign : '') + stringExponent;\n        }\n        // bullet 14:\n        stringValue = pic.prefix + stringValue + pic.suffix;\n        return stringValue;\n    }\n\n    /**\n     * Converts a number to a string using a specified number base\n     * @param {number} value - the number to convert\n     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10\n     * @returns {string} - the converted string\n     */\n    function formatBase(value, radix) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = round(value);\n\n        if (typeof radix === 'undefined') {\n            radix = 10;\n        } else {\n            radix = round(radix);\n        }\n\n        if (radix < 2 || radix > 36) {\n            throw {\n                code: 'D3100',\n                stack: (new Error()).stack,\n                value: radix\n            };\n\n        }\n\n        var result = value.toString(radix);\n\n        return result;\n    }\n\n    /**\n     * Cast argument to number\n     * @param {Object} arg - Argument\n     * @returns {Number} numeric value of argument\n     */\n    function number(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof arg === 'number') {\n            // already a number\n            result = arg;\n        } else if (typeof arg === 'string' && /^-?[0-9]+(\\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {\n            result = parseFloat(arg);\n        } else if (typeof arg === 'string' && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(arg)) {\n            result = Number(arg);\n        } else if (arg === true) {\n            // boolean true casts to 1\n            result = 1;\n        } else if (arg === false) {\n            // boolean false casts to 0\n            result = 0;\n        } else {\n            throw {\n                code: \"D3030\",\n                value: arg,\n                stack: (new Error()).stack,\n                index: 1\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Absolute value of a number\n     * @param {Number} arg - Argument\n     * @returns {Number} absolute value of argument\n     */\n    function abs(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.abs(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number down to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function floor(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.floor(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number up to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function ceil(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.ceil(arg);\n        return result;\n    }\n\n    /**\n     * Round to half even\n     * @param {Number} arg - Argument\n     * @param {Number} [precision] - number of decimal places\n     * @returns {Number} rounded integer\n     */\n    function round(arg, precision) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (precision) {\n            // shift the decimal place - this needs to be done in a string since multiplying\n            // by a power of ten can introduce floating point precision errors which mess up\n            // this rounding algorithm - See 'Decimal rounding' in\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n            // Shift\n            var value = arg.toString().split('e');\n            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));\n\n        }\n\n        // round up to nearest int\n        result = Math.round(arg);\n        var diff = result - arg;\n        if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {\n            // rounded the wrong way - adjust to nearest even number\n            result = result - 1;\n        }\n        if (precision) {\n            // Shift back\n            value = result.toString().split('e');\n            /* istanbul ignore next */\n            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));\n        }\n        if (Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way\n            // JSON doesn't do -0\n            result = 0;\n        }\n        return result;\n    }\n\n    /**\n     * Square root of number\n     * @param {Number} arg - Argument\n     * @returns {Number} square root\n     */\n    function sqrt(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (arg < 0) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3060\",\n                index: 1,\n                value: arg\n            };\n        }\n\n        result = Math.sqrt(arg);\n\n        return result;\n    }\n\n    /**\n     * Raises number to the power of the second number\n     * @param {Number} arg - the base\n     * @param {Number} exp - the exponent\n     * @returns {Number} rounded integer\n     */\n    function power(arg, exp) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.pow(arg, exp);\n\n        if (!isFinite(result)) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3061\",\n                index: 1,\n                value: arg,\n                exp: exp\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns a random number 0 <= n < 1\n     * @returns {number} random number\n     */\n    function random() {\n        return Math.random();\n    }\n\n    /**\n     * Evaluate an input and return a boolean\n     * @param {*} arg - Arguments\n     * @returns {boolean} Boolean\n     */\n    function boolean(arg) {\n        // cast arg to its effective boolean value\n        // boolean: unchanged\n        // string: zero-length -> false; otherwise -> true\n        // number: 0 -> false; otherwise -> true\n        // null -> false\n        // array: empty -> false; length > 1 -> true\n        // object: empty -> false; non-empty -> true\n        // function -> false\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = false;\n        if (Array.isArray(arg)) {\n            if (arg.length === 1) {\n                result = boolean(arg[0]);\n            } else if (arg.length > 1) {\n                var trues = arg.filter(function (val) {\n                    return boolean(val);\n                });\n                result = trues.length > 0;\n            }\n        } else if (typeof arg === 'string') {\n            if (arg.length > 0) {\n                result = true;\n            }\n        } else if (isNumeric(arg)) {\n            if (arg !== 0) {\n                result = true;\n            }\n        } else if (arg !== null && typeof arg === 'object' && !isFunction(arg)) {\n            if (Object.keys(arg).length > 0) {\n                result = true;\n            }\n        } else if (typeof arg === 'boolean' && arg === true) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * returns the Boolean NOT of the arg\n     * @param {*} arg - argument\n     * @returns {boolean} - NOT arg\n     */\n    function not(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return !boolean(arg);\n    }\n\n    /**\n     * Helper function to build the arguments to be supplied to the function arg of the\n     * HOFs map, filter, each, sift and single\n     * @param {function} func - the function to be invoked\n     * @param {*} arg1 - the first (required) arg - the value\n     * @param {*} arg2 - the second (optional) arg - the position (index or key)\n     * @param {*} arg3 - the third (optional) arg - the whole structure (array or object)\n     * @returns {*[]} the argument list\n     */\n    function hofFuncArgs(func, arg1, arg2, arg3) {\n        var func_args = [arg1]; // the first arg (the value) is required\n        // the other two are optional - only supply it if the function can take it\n        var length = getFunctionArity(func);\n        if (length >= 2) {\n            func_args.push(arg2);\n        }\n        if (length >= 3) {\n            func_args.push(arg3);\n        }\n        return func_args;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to map over\n     * @param {Function} func - function to apply\n     * @returns {Array} Map array\n     */\n    async function map(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n        // do the map - iterate over the arrays, and invoke func\n        for (var i = 0; i < arr.length; i++) {\n            var func_args = hofFuncArgs(func, arr[i], i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to filter\n     * @param {Function} func - predicate function\n     * @returns {Array} Map array\n     */\n    async function filter(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var func_args = hofFuncArgs(func, entry, i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result.push(entry);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Given an array, find the single element matching a specified condition\n     * Throws an exception if the number of matching elements is not exactly one\n     * @param {Array} [arr] - array to filter\n     * @param {Function} [func] - predicate function\n     * @returns {*} Matching element\n     */\n    async function single(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var hasFoundMatch = false;\n        var result;\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var positiveResult = true;\n            if (typeof func !== 'undefined') {\n                var func_args = hofFuncArgs(func, entry, i, arr);\n                // invoke func\n                var res = await func.apply(this, func_args);\n                positiveResult = boolean(res);\n            }\n            if (positiveResult) {\n                if(!hasFoundMatch) {\n                    result = entry;\n                    hasFoundMatch = true;\n                } else {\n                    throw {\n                        stack: (new Error()).stack,\n                        code: \"D3138\",\n                        index: i\n                    };\n                }\n            }\n        }\n\n        if(!hasFoundMatch) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3139\"\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Convolves (zips) each value from a set of arrays\n     * @param {Array} [args] - arrays to zip\n     * @returns {Array} Zipped array\n     */\n    function zip() {\n        // this can take a variable number of arguments\n        var result = [];\n        var args = Array.prototype.slice.call(arguments);\n        // length of the shortest array\n        var length = Math.min.apply(Math, args.map(function (arg) {\n            if (Array.isArray(arg)) {\n                return arg.length;\n            }\n            return 0;\n        }));\n        for (var i = 0; i < length; i++) {\n            var tuple = args.map((arg) => {\n                return arg[i];\n            });\n            result.push(tuple);\n        }\n        return result;\n    }\n\n    /**\n     * Fold left function\n     * @param {Array} sequence - Sequence\n     * @param {Function} func - Function\n     * @param {Object} init - Initial value\n     * @returns {*} Result\n     */\n    async function foldLeft(sequence, func, init) {\n        // undefined inputs always return undefined\n        if (typeof sequence === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        var arity = getFunctionArity(func);\n        if (arity < 2) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3050\",\n                index: 1\n            };\n        }\n\n        var index;\n        if (typeof init === 'undefined' && sequence.length > 0) {\n            result = sequence[0];\n            index = 1;\n        } else {\n            result = init;\n            index = 0;\n        }\n\n        while (index < sequence.length) {\n            var args = [result, sequence[index]];\n            if (arity >= 3) {\n                args.push(index);\n            }\n            if (arity >= 4) {\n                args.push(sequence);\n            }\n            result = await func.apply(this, args);\n            index++;\n        }\n\n        return result;\n    }\n\n    /**\n     * Return keys for an object\n     * @param {Object} arg - Object\n     * @returns {Array} Array of keys\n     */\n    function keys(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // merge the keys of all of the items in the array\n            var merge = {};\n            arg.forEach(function (item) {\n                var allkeys = keys(item);\n                allkeys.forEach(function (key) {\n                    merge[key] = true;\n                });\n            });\n            result = keys(merge);\n        } else if (arg !== null && typeof arg === 'object' && !isFunction(arg)) {\n            Object.keys(arg).forEach(key => result.push(key));\n        }\n        return result;\n    }\n\n    /**\n     * Return value from an object for a given key\n     * @param {Object} input - Object/Array\n     * @param {String} key - Key in object\n     * @returns {*} Value of key in object\n     */\n    function lookup(input, key) {\n        // lookup the 'name' item in the input\n        var result;\n        if (Array.isArray(input)) {\n            result = createSequence();\n            for(var ii = 0; ii < input.length; ii++) {\n                var res =  lookup(input[ii], key);\n                if (typeof res !== 'undefined') {\n                    if (Array.isArray(res)) {\n                        res.forEach(val => result.push(val));\n                    } else {\n                        result.push(res);\n                    }\n                }\n            }\n        } else if (input !== null && typeof input === 'object' && !isFunction(input)) {\n            result = input[key];\n        }\n        return result;\n    }\n\n    /**\n     * Append second argument to first\n     * @param {Array|Object} arg1 - First argument\n     * @param {Array|Object} arg2 - Second argument\n     * @returns {*} Appended arguments\n     */\n    function append(arg1, arg2) {\n        // disregard undefined args\n        if (typeof arg1 === 'undefined') {\n            return arg2;\n        }\n        if (typeof arg2 === 'undefined') {\n            return arg1;\n        }\n        // if either argument is not an array, make it so\n        if (!Array.isArray(arg1)) {\n            arg1 = createSequence(arg1);\n        }\n        if (!Array.isArray(arg2)) {\n            arg2 = [arg2];\n        }\n        return arg1.concat(arg2);\n    }\n\n    /**\n     * Determines if the argument is undefined\n     * @param {*} arg - argument\n     * @returns {boolean} False if argument undefined, otherwise true\n     */\n    function exists(arg) {\n        if (typeof arg === 'undefined') {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Splits an object into an array of object with one property each\n     * @param {*} arg - the object to split\n     * @returns {*} - the array\n     */\n    function spread(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // spread all of the items in the array\n            arg.forEach(function (item) {\n                result = append(result, spread(item));\n            });\n        } else if (arg !== null && typeof arg === 'object' && !isLambda(arg)) {\n            for (var key in arg) {\n                var obj = {};\n                obj[key] = arg[key];\n                result.push(obj);\n            }\n        } else {\n            result = arg;\n        }\n        return result;\n    }\n\n    /**\n     * Merges an array of objects into a single object.  Duplicate properties are\n     * overridden by entries later in the array\n     * @param {*} arg - the objects to merge\n     * @returns {*} - the object\n     */\n    function merge(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = {};\n\n        arg.forEach(function (obj) {\n            for (var prop in obj) {\n                result[prop] = obj[prop];\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Reverses the order of items in an array\n     * @param {Array} arr - the array to reverse\n     * @returns {Array} - the reversed array\n     */\n    function reverse(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var length = arr.length;\n        var result = new Array(length);\n        for (var i = 0; i < length; i++) {\n            result[length - i - 1] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {*} obj - the input object to iterate over\n     * @param {*} func - the function to apply to each key/value pair\n     * @returns {Array} - the resultant array\n     */\n    async function each(obj, func) {\n        var result = createSequence();\n\n        for (var key in obj) {\n            var func_args = hofFuncArgs(func, obj[key], key, obj);\n            // invoke func\n            var val = await func.apply(this, func_args);\n            if(typeof val !== 'undefined') {\n                result.push(val);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     */\n    function error(message) {\n        throw {\n            code: \"D3137\",\n            stack: (new Error()).stack,\n            message: message || \"$error() function evaluated\"\n        };\n    }\n\n    /**\n     *\n     * @param {boolean} condition - the condition to evaluate\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     * @returns {undefined}\n     */\n    function assert(condition, message) {\n        if(!condition) {\n            throw {\n                code: \"D3141\",\n                stack: (new Error()).stack,\n                message: message || \"$assert() statement failed\"\n            };\n        }\n\n        return undefined;\n    }\n\n    /**\n     *\n     * @param {*} [value] - the input to which the type will be checked\n     * @returns {string} - the type of the input\n     */\n    function type(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n\n        if (value === null) {\n            return 'null';\n        }\n\n        if (isNumeric(value)) {\n            return 'number';\n        }\n\n        if (typeof value === 'string') {\n            return 'string';\n        }\n\n        if (typeof value === 'boolean') {\n            return 'boolean';\n        }\n\n        if(Array.isArray(value)) {\n            return 'array';\n        }\n\n        if(isFunction(value)) {\n            return 'function';\n        }\n\n        return 'object';\n    }\n\n    /**\n     * Implements the merge sort (stable) with optional comparator function\n     *\n     * @param {Array} arr - the array to sort\n     * @param {*} comparator - comparator function\n     * @returns {Array} - sorted array\n     */\n    async function sort(arr, comparator) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var comp;\n        if (typeof comparator === 'undefined') {\n            // inject a default comparator - only works for numeric or string arrays\n            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3070\",\n                    index: 1\n                };\n            }\n\n            comp = async function (a, b) {\n                return a > b;\n            };\n        } else {\n            // for internal usage of functionSort (i.e. order-by syntax)\n            comp = comparator;\n        }\n\n        var merge = async function (l, r) {\n            var merge_iter = async function (result, left, right) {\n                if (left.length === 0) {\n                    Array.prototype.push.apply(result, right);\n                } else if (right.length === 0) {\n                    Array.prototype.push.apply(result, left);\n                } else if (await comp(left[0], right[0])) { // invoke the comparator function\n                    // if it returns true - swap left and right\n                    result.push(right[0]);\n                    await merge_iter(result, left, right.slice(1));\n                } else {\n                    // otherwise keep the same order\n                    result.push(left[0]);\n                    await merge_iter(result, left.slice(1), right);\n                }\n            };\n            var merged = [];\n            await merge_iter(merged, l, r);\n            return merged;\n        };\n\n        var msort = async function (array) {\n            if (!Array.isArray(array) || array.length <= 1) {\n                return array;\n            } else {\n                var middle = Math.floor(array.length / 2);\n                var left = array.slice(0, middle);\n                var right = array.slice(middle);\n                left = await msort(left);\n                right = await msort(right);\n                return await merge(left, right);\n            }\n        };\n\n        var result = await msort(arr);\n\n        return result;\n    }\n\n    /**\n     * Randomly shuffles the contents of an array\n     * @param {Array} arr - the input array\n     * @returns {Array} the shuffled array\n     */\n    function shuffle(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm\n        var result = new Array(arr.length);\n        for (var i = 0; i < arr.length; i++) {\n            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 \u2264 j \u2264 i\n            if (i !== j) {\n                result[i] = result[j];\n            }\n            result[j] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the values that appear in a sequence, with duplicates eliminated.\n     * @param {Array} arr - An array or sequence of values\n     * @returns {Array} - sequence of distinct values\n     */\n    function distinct(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if(!Array.isArray(arr) || arr.length <= 1) {\n            return arr;\n        }\n\n        var results = isSequence(arr) ? createSequence() : [];\n\n        for(var ii = 0; ii < arr.length; ii++) {\n            var value = arr[ii];\n            // is this value already in the result sequence?\n            var includes = false;\n            for(var jj = 0; jj < results.length; jj++) {\n                if (deepEquals(value, results[jj])) {\n                    includes = true;\n                    break;\n                }\n            }\n            if(!includes) {\n                results.push(value);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Applies a predicate function to each key/value pair in an object, and returns an object containing\n     * only the key/value pairs that passed the predicate\n     *\n     * @param {object} arg - the object to be sifted\n     * @param {object} func - the predicate function (lambda or native)\n     * @returns {object} - sifted object\n     */\n    async function sift(arg, func) {\n        var result = {};\n\n        for (var item in arg) {\n            var entry = arg[item];\n            var func_args = hofFuncArgs(func, entry, item, arg);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result[item] = entry;\n            }\n        }\n\n        // empty objects should be changed to undefined\n        if (Object.keys(result).length === 0) {\n            result = undefined;\n        }\n\n        return result;\n    }\n\n    return {\n        sum, count, max, min, average,\n        string, substring, substringBefore, substringAfter, lowercase, uppercase, length, trim, pad,\n        match, contains, replace, split, join,\n        formatNumber, formatBase, number, floor, ceil, round, abs, sqrt, power, random,\n        boolean, not,\n        map, zip, filter, single, foldLeft, sift,\n        keys, lookup, append, exists, spread, merge, reverse, each, error, assert, type, sort, shuffle, distinct,\n        base64encode, base64decode,  encodeUrlComponent, encodeUrl, decodeUrlComponent, decodeUrl\n    };\n})();\n\nmodule.exports = functions;\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./utils\":6}],3:[function(require,module,exports){\n/**\n * \u00A9 Copyright IBM Corp. 2016, 2017 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\n/**\n * @module JSONata\n * @description JSON query and transformation language\n */\n\nvar datetime = require('./datetime');\nvar fn = require('./functions');\nvar utils = require('./utils');\nvar parser = require('./parser');\nvar parseSignature = require('./signature');\n\n/**\n * jsonata\n * @function\n * @param {Object} expr - JSONata expression\n * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n */\nvar jsonata = (function() {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isIterable = utils.isIterable;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var isDeepEqual = utils.isDeepEqual;\n\n    // Start of Evaluator code\n\n    var staticFrame = createFrame(null);\n\n    /**\n     * Evaluate expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluate(expr, input, environment) {\n        var result;\n\n        var entryCallback = environment.lookup(Symbol.for('jsonata.__evaluate_entry'));\n        if(entryCallback) {\n            await entryCallback(expr, input, environment);\n        }\n\n        switch (expr.type) {\n            case 'path':\n                result = await evaluatePath(expr, input, environment);\n                break;\n            case 'binary':\n                result = await evaluateBinary(expr, input, environment);\n                break;\n            case 'unary':\n                result = await evaluateUnary(expr, input, environment);\n                break;\n            case 'name':\n                result = evaluateName(expr, input, environment);\n                break;\n            case 'string':\n            case 'number':\n            case 'value':\n                result = evaluateLiteral(expr, input, environment);\n                break;\n            case 'wildcard':\n                result = evaluateWildcard(expr, input, environment);\n                break;\n            case 'descendant':\n                result = evaluateDescendants(expr, input, environment);\n                break;\n            case 'parent':\n                result = environment.lookup(expr.slot.label);\n                break;\n            case 'condition':\n                result = await evaluateCondition(expr, input, environment);\n                break;\n            case 'block':\n                result = await evaluateBlock(expr, input, environment);\n                break;\n            case 'bind':\n                result = await evaluateBindExpression(expr, input, environment);\n                break;\n            case 'regex':\n                result = evaluateRegex(expr, input, environment);\n                break;\n            case 'function':\n                result = await evaluateFunction(expr, input, environment);\n                break;\n            case 'variable':\n                result = evaluateVariable(expr, input, environment);\n                break;\n            case 'lambda':\n                result = evaluateLambda(expr, input, environment);\n                break;\n            case 'partial':\n                result = await evaluatePartialApplication(expr, input, environment);\n                break;\n            case 'apply':\n                result = await evaluateApplyExpression(expr, input, environment);\n                break;\n            case 'transform':\n                result = evaluateTransformExpression(expr, input, environment);\n                break;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(expr, 'predicate')) {\n            for(var ii = 0; ii < expr.predicate.length; ii++) {\n                result = await evaluateFilter(expr.predicate[ii].expr, result, environment);\n            }\n        }\n\n        if (expr.type !== 'path' && Object.prototype.hasOwnProperty.call(expr, 'group')) {\n            result = await evaluateGroupExpression(expr.group, result, environment);\n        }\n\n        var exitCallback = environment.lookup(Symbol.for('jsonata.__evaluate_exit'));\n        if(exitCallback) {\n            await exitCallback(expr, input, environment, result);\n        }\n\n        if(result && isSequence(result) && !result.tupleStream) {\n            if(expr.keepArray) {\n                result.keepSingleton = true;\n            }\n            if(result.length === 0) {\n                result = undefined;\n            } else if(result.length === 1) {\n                result =  result.keepSingleton ? result : result[0];\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate path expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePath(expr, input, environment) {\n        var inputSequence;\n        // expr is an array of steps\n        // if the first step is a variable reference ($...), including root reference ($$),\n        //   then the path is absolute rather than relative\n        if (Array.isArray(input) && expr.steps[0].type !== 'variable') {\n            inputSequence = input;\n        } else {\n            // if input is not an array, make it so\n            inputSequence = createSequence(input);\n        }\n\n        var resultSequence;\n        var isTupleStream = false;\n        var tupleBindings = undefined;\n\n        // evaluate each step in turn\n        for(var ii = 0; ii < expr.steps.length; ii++) {\n            var step = expr.steps[ii];\n\n            if(step.tuple) {\n                isTupleStream = true;\n            }\n\n            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)\n            if(ii === 0 && step.consarray) {\n                resultSequence = await evaluate(step, inputSequence, environment);\n            } else {\n                if(isTupleStream) {\n                    tupleBindings = await evaluateTupleStep(step, inputSequence, tupleBindings, environment);\n                } else {\n                    resultSequence = await evaluateStep(step, inputSequence, environment, ii === expr.steps.length - 1);\n                }\n            }\n\n            if (!isTupleStream && (typeof resultSequence === 'undefined' || resultSequence.length === 0)) {\n                break;\n            }\n\n            if(typeof step.focus === 'undefined') {\n                inputSequence = resultSequence;\n            }\n\n        }\n\n        if(isTupleStream) {\n            if(expr.tuple) {\n                // tuple stream is carrying ancestry information - keep this\n                resultSequence = tupleBindings;\n            } else {\n                resultSequence = createSequence();\n                for (ii = 0; ii < tupleBindings.length; ii++) {\n                    resultSequence.push(tupleBindings[ii]['@']);\n                }\n            }\n        }\n\n        if(expr.keepSingletonArray) {\n            // if the array is explicitly constructed in the expression and marked to promote singleton sequences to array\n            if(Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {\n                resultSequence = createSequence(resultSequence);\n            }\n            resultSequence.keepSingleton = true;\n        }\n\n        if (expr.hasOwnProperty('group')) {\n            resultSequence = await evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment)\n        }\n\n        return resultSequence;\n    }\n\n    function createFrameFromTuple(environment, tuple) {\n        var frame = createFrame(environment);\n        for(const prop in tuple) {\n            frame.bind(prop, tuple[prop]);\n        }\n        return frame;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @param {boolean} lastStep - flag the last step in a path\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateStep(expr, input, environment, lastStep) {\n        var result;\n        if(expr.type === 'sort') {\n             result = await evaluateSortExpression(expr, input, environment);\n             if(expr.stages) {\n                 result = await evaluateStages(expr.stages, result, environment);\n             }\n             return result;\n        }\n\n        result = createSequence();\n\n        for(var ii = 0; ii < input.length; ii++) {\n            var res = await evaluate(expr, input[ii], environment);\n            if(expr.stages) {\n                for(var ss = 0; ss < expr.stages.length; ss++) {\n                    res = await evaluateFilter(expr.stages[ss].expr, res, environment);\n                }\n            }\n            if(typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        var resultSequence = createSequence();\n        if(lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {\n            resultSequence = result[0];\n        } else {\n            // flatten the sequence\n            result.forEach(function(res) {\n                if (!Array.isArray(res) || res.cons) {\n                    // it's not an array - just push into the result sequence\n                    resultSequence.push(res);\n                } else {\n                    // res is a sequence - flatten it into the parent sequence\n                    res.forEach(val => resultSequence.push(val));\n                }\n            });\n        }\n\n        return resultSequence;\n    }\n\n    async function evaluateStages(stages, input, environment) {\n        var result = input;\n        for(var ss = 0; ss < stages.length; ss++) {\n            var stage = stages[ss];\n            switch(stage.type) {\n                case 'filter':\n                    result = await evaluateFilter(stage.expr, result, environment);\n                    break;\n                case 'index':\n                    for(var ee = 0; ee < result.length; ee++) {\n                        var tuple = result[ee];\n                        tuple[stage.value] = ee;\n                    }\n                    break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} tupleBindings - The tuple stream\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateTupleStep(expr, input, tupleBindings, environment) {\n        var result;\n        if(expr.type === 'sort') {\n            if(tupleBindings) {\n                result = await evaluateSortExpression(expr, tupleBindings, environment);\n            } else {\n                var sorted = await evaluateSortExpression(expr, input, environment);\n                result = createSequence();\n                result.tupleStream = true;\n                for(var ss = 0; ss < sorted.length; ss++) {\n                    var tuple = {'@': sorted[ss]};\n                    tuple[expr.index] = ss;\n                    result.push(tuple);\n                }\n            }\n            if(expr.stages) {\n                result = await evaluateStages(expr.stages, result, environment);\n            }\n            return result;\n        }\n\n        result = createSequence();\n        result.tupleStream = true;\n        var stepEnv = environment;\n        if(tupleBindings === undefined) {\n            tupleBindings = input.map(item => { return {'@': item} });\n        }\n\n        for(var ee = 0; ee < tupleBindings.length; ee++) {\n            stepEnv = createFrameFromTuple(environment, tupleBindings[ee]);\n            var res = await evaluate(expr, tupleBindings[ee]['@'], stepEnv);\n            // res is the binding sequence for the output tuple stream\n            if(typeof res !== 'undefined') {\n                if (!Array.isArray(res)) {\n                    res = [res];\n                }\n                for (var bb = 0; bb < res.length; bb++) {\n                    tuple = {};\n                    Object.assign(tuple, tupleBindings[ee]);\n                    if(res.tupleStream) {\n                        Object.assign(tuple, res[bb]);\n                    } else {\n                        if (expr.focus) {\n                            tuple[expr.focus] = res[bb];\n                            tuple['@'] = tupleBindings[ee]['@'];\n                        } else {\n                            tuple['@'] = res[bb];\n                        }\n                        if (expr.index) {\n                            tuple[expr.index] = bb;\n                        }\n                        if (expr.ancestor) {\n                            tuple[expr.ancestor.label] = tupleBindings[ee]['@'];\n                        }\n                    }\n                    result.push(tuple);\n                }\n            }\n        }\n\n        if(expr.stages) {\n            result = await evaluateStages(expr.stages, result, environment);\n        }\n\n        return result;\n    }\n\n    /**\n     * Apply filter predicate to input data\n     * @param {Object} predicate - filter expression\n     * @param {Object} input - Input data to apply predicates against\n     * @param {Object} environment - Environment\n     * @returns {*} Result after applying predicates\n     */\n    async function evaluateFilter(predicate, input, environment) {\n        var results = createSequence();\n        if( input && input.tupleStream) {\n            results.tupleStream = true;\n        }\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        if (predicate.type === 'number') {\n            var index = Math.floor(predicate.value);  // round it down\n            if (index < 0) {\n                // count in from end of array\n                index = input.length + index;\n            }\n            var item = await input[index];\n            if(typeof item !== 'undefined') {\n                if(Array.isArray(item)) {\n                    results = item;\n                } else {\n                    results.push(item);\n                }\n            }\n        } else {\n            for (index = 0; index < input.length; index++) {\n                var item = input[index];\n                var context = item;\n                var env = environment;\n                if(input.tupleStream) {\n                    context = item['@'];\n                    env = createFrameFromTuple(environment, item);\n                }\n                var res = await evaluate(predicate, context, env);\n                if (isNumeric(res)) {\n                    res = [res];\n                }\n                if (isArrayOfNumbers(res)) {\n                    res.forEach(function (ires) {\n                        // round it down\n                        var ii = Math.floor(ires);\n                        if (ii < 0) {\n                            // count in from end of array\n                            ii = input.length + ii;\n                        }\n                        if (ii === index) {\n                            results.push(item);\n                        }\n                    });\n                } else if (fn.boolean(res)) { // truthy\n                    results.push(item);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Evaluate binary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBinary(expr, input, environment) {\n        var result;\n        var lhs = await evaluate(expr.lhs, input, environment);\n        var op = expr.value;\n\n        //defer evaluation of RHS to allow short-circuiting\n        var evalrhs = async () => await evaluate(expr.rhs, input, environment);\n        if (op === \"and\" || op === \"or\") {\n            try {\n                return await evaluateBooleanExpression(lhs, evalrhs, op);\n            } catch(err) {\n                err.position = expr.position;\n                err.token = op;\n                throw err;\n            }\n        }\n\n        var rhs = await evalrhs();\n        try {\n            switch (op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                    result = evaluateNumericExpression(lhs, rhs, op);\n                    break;\n                case '=':\n                case '!=':\n                    result = evaluateEqualityExpression(lhs, rhs, op);\n                    break;\n                case '<':\n                case '<=':\n                case '>':\n                case '>=':\n                    result = evaluateComparisonExpression(lhs, rhs, op);\n                    break;\n                case '&':\n                    result = evaluateStringConcat(lhs, rhs);\n                    break;\n                case '..':\n                    result = evaluateRangeExpression(lhs, rhs);\n                    break;\n                case 'in':\n                    result = evaluateIncludesExpression(lhs, rhs);\n                    break;\n            }\n        } catch(err) {\n            err.position = expr.position;\n            err.token = op;\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate unary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateUnary(expr, input, environment) {\n        var result;\n\n        switch (expr.value) {\n            case '-':\n                result = await evaluate(expr.expression, input, environment);\n                if(typeof result === 'undefined') {\n                    result = undefined;\n                } else if (isNumeric(result)) {\n                    result = -result;\n                } else {\n                    throw {\n                        code: \"D1002\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        token: expr.value,\n                        value: result\n                    };\n                }\n                break;\n            case '[':\n                // array constructor - evaluate each item\n                result = [];\n                let generators = await Promise.all(expr.expressions\n                    .map(async (item, idx) => {\n                        environment.isParallelCall = idx > 0\n                        return [item, await evaluate(item, input, environment)]\n                    }));\n                for (let generator of generators) {\n                    var [item, value] = generator;\n                    if (typeof value !== 'undefined') {\n                        if(item.value === '[') {\n                            result.push(value);\n                        } else {\n                            result = fn.append(result, value);\n                        }\n                    }\n                }\n                if(expr.consarray) {\n                    Object.defineProperty(result, 'cons', {\n                        enumerable: false,\n                        configurable: false,\n                        value: true\n                    });\n                }\n                break;\n            case '{':\n                // object constructor - apply grouping\n                result = await evaluateGroupExpression(expr, input, environment);\n                break;\n\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate name object against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateName(expr, input, environment) {\n        // lookup the 'name' item in the input\n        return fn.lookup(input, expr.value);\n    }\n\n    /**\n     * Evaluate literal against input data\n     * @param {Object} expr - JSONata expression\n     * @returns {*} Evaluated input data\n     */\n    function evaluateLiteral(expr) {\n        return expr.value;\n    }\n\n    /**\n     * Evaluate wildcard against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateWildcard(expr, input) {\n        var results = createSequence();\n        if (Array.isArray(input) && input.outerWrapper && input.length > 0) {\n            input = input[0];\n        }\n        if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                var value = input[key];\n                if(Array.isArray(value)) {\n                    value = flatten(value);\n                    results = fn.append(results, value);\n                } else {\n                    results.push(value);\n                }\n            });\n        }\n\n        //        result = normalizeSequence(results);\n        return results;\n    }\n\n    /**\n     * Returns a flattened array\n     * @param {Array} arg - the array to be flatten\n     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []\n     * @returns {Array} - the flattened array\n     */\n    function flatten(arg, flattened) {\n        if(typeof flattened === 'undefined') {\n            flattened = [];\n        }\n        if(Array.isArray(arg)) {\n            arg.forEach(function (item) {\n                flatten(item, flattened);\n            });\n        } else {\n            flattened.push(arg);\n        }\n        return flattened;\n    }\n\n    /**\n     * Evaluate descendants against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateDescendants(expr, input) {\n        var result;\n        var resultSequence = createSequence();\n        if (typeof input !== 'undefined') {\n            // traverse all descendants of this object/array\n            recurseDescendants(input, resultSequence);\n            if (resultSequence.length === 1) {\n                result = resultSequence[0];\n            } else {\n                result = resultSequence;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Recurse through descendants\n     * @param {Object} input - Input data\n     * @param {Object} results - Results\n     */\n    function recurseDescendants(input, results) {\n        // this is the equivalent of //* in XPath\n        if (!Array.isArray(input)) {\n            results.push(input);\n        }\n        if (Array.isArray(input)) {\n            input.forEach(function (member) {\n                recurseDescendants(member, results);\n            });\n        } else if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                recurseDescendants(input[key], results);\n            });\n        }\n    }\n\n    /**\n     * Evaluate numeric expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateNumericExpression(lhs, rhs, op) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !isNumeric(lhs)) {\n            throw {\n                code: \"T2001\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !isNumeric(rhs)) {\n            throw {\n                code: \"T2002\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        switch (op) {\n            case '+':\n                result = lhs + rhs;\n                break;\n            case '-':\n                result = lhs - rhs;\n                break;\n            case '*':\n                result = lhs * rhs;\n                break;\n            case '/':\n                result = lhs / rhs;\n                break;\n            case '%':\n                result = lhs % rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate equality expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateEqualityExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        switch (op) {\n            case '=':\n                result = isDeepEqual(lhs, rhs);\n                break;\n            case '!=':\n                result = !isDeepEqual(lhs, rhs);\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate comparison expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateComparisonExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        var lcomparable = (ltype === 'undefined' || ltype === 'string' || ltype === 'number');\n        var rcomparable = (rtype === 'undefined' || rtype === 'string' || rtype === 'number');\n\n        // if either aa or bb are not comparable (string or numeric) values, then throw an error\n        if (!lcomparable || !rcomparable) {\n            throw {\n                code: \"T2010\",\n                stack: (new Error()).stack,\n                value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs\n            };\n        }\n\n        // if either side is undefined, the result is undefined\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            return undefined;\n        }\n\n        //if aa and bb are not of the same type\n        if (ltype !== rtype) {\n            throw {\n                code: \"T2009\",\n                stack: (new Error()).stack,\n                value: lhs,\n                value2: rhs\n            };\n        }\n\n        switch (op) {\n            case '<':\n                result = lhs < rhs;\n                break;\n            case '<=':\n                result = lhs <= rhs;\n                break;\n            case '>':\n                result = lhs > rhs;\n                break;\n            case '>=':\n                result = lhs >= rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Inclusion operator - in\n     *\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {boolean} - true if lhs is a member of rhs\n     */\n    function evaluateIncludesExpression(lhs, rhs) {\n        var result = false;\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        if(!Array.isArray(rhs)) {\n            rhs = [rhs];\n        }\n\n        for(var i = 0; i < rhs.length; i++) {\n            if(rhs[i] === lhs) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate boolean expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Function} evalrhs - function to evaluate RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    async function evaluateBooleanExpression(lhs, evalrhs, op) {\n        var result;\n\n        var lBool = boolize(lhs);\n\n        switch (op) {\n            case 'and':\n                result = lBool && boolize(await evalrhs());\n                break;\n            case 'or':\n                result = lBool || boolize(await evalrhs());\n                break;\n        }\n        return result;\n    }\n\n    function boolize(value) {\n        var booledValue = fn.boolean(value);\n        return typeof booledValue === 'undefined' ? false : booledValue;\n    }\n\n    /**\n     * Evaluate string concatenation against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {string|*} Concatenated string\n     */\n    function evaluateStringConcat(lhs, rhs) {\n        var result;\n\n        var lstr = '';\n        var rstr = '';\n        if (typeof lhs !== 'undefined') {\n            lstr = fn.string(lhs);\n        }\n        if (typeof rhs !== 'undefined') {\n            rstr = fn.string(rhs);\n        }\n\n        result = lstr.concat(rstr);\n        return result;\n    }\n\n    /**\n     * Evaluate group expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{}} Evaluated input data\n     */\n    async function evaluateGroupExpression(expr, input, environment) {\n        var result = {};\n        var groups = {};\n        var reduce = input && input.tupleStream ? true : false;\n        // group the input sequence by 'key' expression\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        // if the array is empty, add an undefined entry to enable literal JSON object to be generated\n        if (input.length === 0) {\n            input.push(undefined);\n        }\n\n        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {\n            var item = input[itemIndex];\n            var env = reduce ? createFrameFromTuple(environment, item) : environment;\n            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {\n                var pair = expr.lhs[pairIndex];\n                var key = await evaluate(pair[0], reduce ? item['@'] : item, env);\n                // key has to be a string\n                if (typeof  key !== 'string' && key !== undefined) {\n                    throw {\n                        code: \"T1003\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: key\n                    };\n                }\n\n                if (key !== undefined) {\n                    var entry = {data: item, exprIndex: pairIndex};\n                    if (groups.hasOwnProperty(key)) {\n                        // a value already exists in this slot\n                        if(groups[key].exprIndex !== pairIndex) {\n                            // this key has been generated by another expression in this group\n                            // when multiple key expressions evaluate to the same key, then error D1009 must be thrown\n                            throw {\n                                code: \"D1009\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: key\n                            };\n                        }\n\n                        // append it as an array\n                        groups[key].data = fn.append(groups[key].data, item);\n                    } else {\n                        groups[key] = entry;\n                    }\n                }\n            }\n        }\n\n        // iterate over the groups to evaluate the 'value' expression\n        let generators = await Promise.all(Object.keys(groups).map(async (key, idx) => {\n            let entry = groups[key];\n            var context = entry.data;\n            var env = environment;\n            if (reduce) {\n                var tuple = reduceTupleStream(entry.data);\n                context = tuple['@'];\n                delete tuple['@'];\n                env = createFrameFromTuple(environment, tuple);\n            }\n            environment.isParallelCall = idx > 0\n            return [key, await evaluate(expr.lhs[entry.exprIndex][1], context, env)];\n        }));\n\n        for (let generator of generators) {\n            var [key, value] = await generator;\n            if(typeof value !== 'undefined') {\n                result[key] = value;\n            }\n        }\n\n        return result;\n    }\n\n    function reduceTupleStream(tupleStream) {\n        if(!Array.isArray(tupleStream)) {\n            return tupleStream;\n        }\n        var result = {};\n        Object.assign(result, tupleStream[0]);\n        for(var ii = 1; ii < tupleStream.length; ii++) {\n            for(const prop in tupleStream[ii]) {\n                result[prop] = fn.append(result[prop], tupleStream[ii][prop]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate range expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {Array} Resultant array\n     */\n    function evaluateRangeExpression(lhs, rhs) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !Number.isInteger(lhs)) {\n            throw {\n                code: \"T2003\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !Number.isInteger(rhs)) {\n            throw {\n                code: \"T2004\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        if (lhs > rhs) {\n            // if the lhs is greater than the rhs, return undefined\n            return result;\n        }\n\n        // limit the size of the array to ten million entries (1e7)\n        // this is an implementation defined limit to protect against\n        // memory and performance issues.  This value may increase in the future.\n        var size = rhs - lhs + 1;\n        if(size > 1e7) {\n            throw {\n                code: \"D2014\",\n                stack: (new Error()).stack,\n                value: size\n            };\n        }\n\n        result = new Array(size);\n        for (var item = lhs, index = 0; item <= rhs; item++, index++) {\n            result[index] = item;\n        }\n        result.sequence = true;\n        return result;\n    }\n\n    /**\n     * Evaluate bind expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBindExpression(expr, input, environment) {\n        // The RHS is the expression to evaluate\n        // The LHS is the name of the variable to bind to - should be a VARIABLE token (enforced by parser)\n        var value = await evaluate(expr.rhs, input, environment);\n        environment.bind(expr.lhs.value, value);\n        return value;\n    }\n\n    /**\n     * Evaluate condition against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateCondition(expr, input, environment) {\n        var result;\n        var condition = await evaluate(expr.condition, input, environment);\n        if (fn.boolean(condition)) {\n            result = await evaluate(expr.then, input, environment);\n        } else if (typeof expr.else !== 'undefined') {\n            result = await evaluate(expr.else, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate block against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBlock(expr, input, environment) {\n        var result;\n        // create a new frame to limit the scope of variable assignments\n        // TODO, only do this if the post-parse stage has flagged this as required\n        var frame = createFrame(environment);\n        // invoke each expression in turn\n        // only return the result of the last one\n        for(var ii = 0; ii < expr.expressions.length; ii++) {\n            result = await evaluate(expr.expressions[ii], input, frame);\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare a regex\n     * @param {Object} expr - expression containing regex\n     * @returns {Function} Higher order function representing prepared regex\n     */\n    function evaluateRegex(expr) {\n        var re = new jsonata.RegexEngine(expr.value);\n        var closure = function(str, fromIndex) {\n            var result;\n            re.lastIndex = fromIndex || 0;\n            var match = re.exec(str);\n            if(match !== null) {\n                result = {\n                    match: match[0],\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    groups: []\n                };\n                if(match.length > 1) {\n                    for(var i = 1; i < match.length; i++) {\n                        result.groups.push(match[i]);\n                    }\n                }\n                result.next = function() {\n                    if(re.lastIndex >= str.length) {\n                        return undefined;\n                    } else {\n                        var next = closure(str, re.lastIndex);\n                        if(next && next.match === '') {\n                            // matches zero length string; this will never progress\n                            throw {\n                                code: \"D1004\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: expr.value.source\n                            };\n                        }\n                        return next;\n                    }\n                };\n            }\n\n            return result;\n        };\n        return closure;\n    }\n\n    /**\n     * Evaluate variable against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateVariable(expr, input, environment) {\n        // lookup the variable value in the environment\n        var result;\n        // if the variable name is empty string, then it refers to context value\n        if (expr.value === '') {\n            result = input && input.outerWrapper ? input[0] : input;\n        } else {\n            result = environment.lookup(expr.value);\n        }\n        return result;\n    }\n\n    /**\n     * sort / order-by operator\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Ordered sequence\n     */\n    async function evaluateSortExpression(expr, input, environment) {\n        var result;\n\n        // evaluate the lhs, then sort the results in order according to rhs expression\n        var lhs = input;\n        var isTupleSort = input.tupleStream ? true : false;\n\n        // sort the lhs array\n        // use comparator function\n        var comparator = async function(a, b) { \n            // expr.terms is an array of order-by in priority order\n            var comp = 0;\n            for(var index = 0; comp === 0 && index < expr.terms.length; index++) {\n                var term = expr.terms[index];\n                //evaluate the sort term in the context of a\n                var context = a;\n                var env = environment;\n                if(isTupleSort) {\n                    context = a['@'];\n                    env = createFrameFromTuple(environment, a);\n                }\n                var aa = await evaluate(term.expression, context, env);\n                //evaluate the sort term in the context of b\n                context = b;\n                env = environment;\n                if(isTupleSort) {\n                    context = b['@'];\n                    env = createFrameFromTuple(environment, b);\n                }\n                var bb = await evaluate(term.expression, context, env);\n\n                // type checks\n                var atype = typeof aa;\n                var btype = typeof bb;\n                // undefined should be last in sort order\n                if(atype === 'undefined') {\n                    // swap them, unless btype is also undefined\n                    comp = (btype === 'undefined') ? 0 : 1;\n                    continue;\n                }\n                if(btype === 'undefined') {\n                    comp = -1;\n                    continue;\n                }\n\n                // if aa or bb are not string or numeric values, then throw an error\n                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {\n                    throw {\n                        code: \"T2008\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: !(atype === 'string' || atype === 'number') ? aa : bb\n                    };\n                }\n\n                //if aa and bb are not of the same type\n                if(atype !== btype) {\n                    throw {\n                        code: \"T2007\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: aa,\n                        value2: bb\n                    };\n                }\n                if(aa === bb) {\n                    // both the same - move on to next term\n                    continue;\n                } else if (aa < bb) {\n                    comp = -1;\n                } else {\n                    comp = 1;\n                }\n                if(term.descending === true) {\n                    comp = -comp;\n                }\n            }\n            // only swap a & b if comp equals 1\n            return comp === 1;\n        };\n\n        var focus = {\n            environment: environment,\n            input: input\n        };\n        // the `focus` is passed in as the `this` for the invoked function\n        result = await fn.sort.apply(focus, [lhs, comparator]);\n\n        return result;\n    }\n\n    /**\n     * create a transformer function\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} tranformer function\n     */\n    function evaluateTransformExpression(expr, input, environment) {\n        // create a function to implement the transform definition\n        var transformer = async function (obj) { // signature <(oa):o>\n            // undefined inputs always return undefined\n            if(typeof obj === 'undefined') {\n                return undefined;\n            }\n\n            // this function returns a copy of obj with changes specified by the pattern/operation\n            var cloneFunction = environment.lookup('clone');\n            if(!isFunction(cloneFunction)) {\n                // throw type error\n                throw {\n                    code: \"T2013\",\n                    stack: (new Error()).stack,\n                    position: expr.position\n                };\n            }\n            var result = await apply(cloneFunction, [obj], null, environment);\n            var matches = await evaluate(expr.pattern, result, environment);\n            if(typeof matches !== 'undefined') {\n                if(!Array.isArray(matches)) {\n                    matches = [matches];\n                }\n                for(var ii = 0; ii < matches.length; ii++) {\n                    var match = matches[ii];\n                    if (match && (match.isPrototypeOf(result) || match instanceof Object.constructor)) {\n                        throw {\n                            code: \"D1010\",\n                            stack: (new Error()).stack,\n                            position: expr.position\n                        };\n                    }\n                    // evaluate the update value for each match\n                    var update = await evaluate(expr.update, match, environment);\n                    // update must be an object\n                    var updateType = typeof update;\n                    if(updateType !== 'undefined') {\n                        if(updateType !== 'object' || update === null || Array.isArray(update)) {\n                            // throw type error\n                            throw {\n                                code: \"T2011\",\n                                stack: (new Error()).stack,\n                                position: expr.update.position,\n                                value: update\n                            };\n                        }\n                        // merge the update\n                        for(var prop in update) {\n                            match[prop] = update[prop];\n                        }\n                    }\n\n                    // delete, if specified, must be an array of strings (or single string)\n                    if(typeof expr.delete !== 'undefined') {\n                        var deletions = await evaluate(expr.delete, match, environment);\n                        if(typeof deletions !== 'undefined') {\n                            var val = deletions;\n                            if (!Array.isArray(deletions)) {\n                                deletions = [deletions];\n                            }\n                            if (!isArrayOfStrings(deletions)) {\n                                // throw type error\n                                throw {\n                                    code: \"T2012\",\n                                    stack: (new Error()).stack,\n                                    position: expr.delete.position,\n                                    value: val\n                                };\n                            }\n                            for (var jj = 0; jj < deletions.length; jj++) {\n                                if(typeof match === 'object' && match !== null) {\n                                    delete match[deletions[jj]];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        return defineFunction(transformer, '<(oa):o>');\n    }\n\n    var chainAST = parser('function($f, $g) { function($x){ $g($f($x)) } }');\n\n    /**\n     * Apply the function on the RHS using the sequence on the LHS as the first argument\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateApplyExpression(expr, input, environment) {\n        var result;\n\n\n        var lhs = await evaluate(expr.lhs, input, environment);\n        if(expr.rhs.type === 'function') {\n            // this is a function _invocation_; invoke it with lhs expression as the first argument\n            result = await evaluateFunction(expr.rhs, input, environment, { context: lhs });\n        } else {\n            var func = await evaluate(expr.rhs, input, environment);\n\n            if(!isFunction(func)) {\n                throw {\n                    code: \"T2006\",\n                    stack: (new Error()).stack,\n                    position: expr.position,\n                    value: func\n                };\n            }\n\n            if(isFunction(lhs)) {\n                // this is function chaining (func1 ~> func2)\n                // \u03BB($f, $g) { \u03BB($x){ $g($f($x)) } }\n                var chain = await evaluate(chainAST, null, environment);\n                result = await apply(chain, [lhs, func], null, environment);\n            } else {\n                result = await apply(func, [lhs], null, environment);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate function against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateFunction(expr, input, environment, applyto) {\n        var result;\n\n        // create the procedure\n        // can't assume that expr.procedure is a lambda type directly\n        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.\n        // evaluate it generically first, then check that it is a function.  Throw error if not.\n        var proc = await evaluate(expr.procedure, input, environment);\n\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1005\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n\n        var evaluatedArgs = [];\n        if(typeof applyto !== 'undefined') {\n            evaluatedArgs.push(applyto.context);\n        }\n        // eager evaluation - evaluate the arguments\n        for (var jj = 0; jj < expr.arguments.length; jj++) {\n            const arg = await evaluate(expr.arguments[jj], input, environment);\n            if(isFunction(arg)) {\n                // wrap this in a closure\n                const closure = async function (...params) {\n                    // invoke func\n                    return await apply(arg, params, null, environment);\n                };\n                closure.arity = getFunctionArity(arg);\n                evaluatedArgs.push(closure);\n            } else {\n                evaluatedArgs.push(arg);\n            }\n        }\n        // apply the procedure\n        var procName = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;\n        try {\n            if(typeof proc === 'object') {\n                proc.token = procName;\n                proc.position = expr.position;\n            }\n            result = await apply(proc, evaluatedArgs, input, environment);\n        } catch (err) {\n            if(!err.position) {\n                // add the position field to the error\n                err.position = expr.position;\n            }\n            if (!err.token) {\n                // and the function identifier\n                err.token = procName;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function apply(proc, args, input, environment) {\n        var result;\n        result = await applyInner(proc, args, input, environment);\n        while(isLambda(result) && result.thunk === true) {\n            // trampoline loop - this gets invoked as a result of tail-call optimization\n            // the function returned a tail-call thunk\n            // unpack it, evaluate its arguments, and apply the tail call\n            var next = await evaluate(result.body.procedure, result.input, result.environment);\n            if(result.body.procedure.type === 'variable') {\n                next.token = result.body.procedure.value;\n            }\n            next.position = result.body.procedure.position;\n            var evaluatedArgs = [];\n            for(var ii = 0; ii < result.body.arguments.length; ii++) {\n                evaluatedArgs.push(await evaluate(result.body.arguments[ii], result.input, result.environment));\n            }\n\n            result = await applyInner(next, evaluatedArgs, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function applyInner(proc, args, input, environment) {\n        var result;\n        try {\n            var validatedArgs = args;\n            if (proc) {\n                validatedArgs = validateArguments(proc.signature, args, input);\n            }\n\n            if (isLambda(proc)) {\n                result = await applyProcedure(proc, validatedArgs);\n            } else if (proc && proc._jsonata_function === true) {\n                var focus = {\n                    environment: environment,\n                    input: input\n                };\n                // the `focus` is passed in as the `this` for the invoked function\n                result = proc.implementation.apply(focus, validatedArgs);\n                // `proc.implementation` might be a generator function\n                // and `result` might be a generator - if so, yield\n                if (isIterable(result)) {\n                    result = result.next().value;\n                }\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else if (typeof proc === 'function') {\n                // typically these are functions that are returned by the invocation of plugin functions\n                // the `input` is being passed in as the `this` for the invoked function\n                // this is so that functions that return objects containing functions can chain\n                // e.g. await (await $func())\n                result = proc.apply(input, validatedArgs);\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else {\n                throw {\n                    code: \"T1006\",\n                    stack: (new Error()).stack\n                };\n            }\n        } catch(err) {\n            if(proc) {\n                if (typeof err.token == 'undefined' && typeof proc.token !== 'undefined') {\n                    err.token = proc.token;\n                }\n                err.position = proc.position || err.position;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate lambda against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data\n     */\n    function evaluateLambda(expr, input, environment) {\n        // make a function (closure)\n        var procedure = {\n            _jsonata_lambda: true,\n            input: input,\n            environment: environment,\n            arguments: expr.arguments,\n            signature: expr.signature,\n            body: expr.body\n        };\n        if(expr.thunk === true) {\n            procedure.thunk = true;\n        }\n        procedure.apply = async function(self, args) {\n            return await apply(procedure, args, input, !!self ? self.environment : environment);\n        };\n        return procedure;\n    }\n\n    /**\n     * Evaluate partial application\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePartialApplication(expr, input, environment) {\n        // partially apply a function\n        var result;\n        // evaluate the arguments\n        var evaluatedArgs = [];\n        for(var ii = 0; ii < expr.arguments.length; ii++) {\n            var arg = expr.arguments[ii];\n            if (arg.type === 'operator' && arg.value === '?') {\n                evaluatedArgs.push(arg);\n            } else {\n                evaluatedArgs.push(await evaluate(arg, input, environment));\n            }\n        }\n        // lookup the procedure\n        var proc = await evaluate(expr.procedure, input, environment);\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1007\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n        if (isLambda(proc)) {\n            result = partialApplyProcedure(proc, evaluatedArgs);\n        } else if (proc && proc._jsonata_function === true) {\n            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);\n        } else if (typeof proc === 'function') {\n            result = partialApplyNativeFunction(proc, evaluatedArgs);\n        } else {\n            throw {\n                code: \"T1008\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Validate the arguments against the signature validator (if it exists)\n     * @param {Function} signature - validator function\n     * @param {Array} args - function arguments\n     * @param {*} context - context value\n     * @returns {Array} - validated arguments\n     */\n    function validateArguments(signature, args, context) {\n        if(typeof signature === 'undefined') {\n            // nothing to validate\n            return args;\n        }\n        var validatedArgs = signature.validate(args, context);\n        return validatedArgs;\n    }\n\n    /**\n     * Apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {*} Result of procedure\n     */\n    async function applyProcedure(proc, args) {\n        var result;\n        var env = createFrame(proc.environment);\n        proc.arguments.forEach(function (param, index) {\n            env.bind(param.value, args[index]);\n        });\n        if (typeof proc.body === 'function') {\n            // this is a lambda that wraps a native function - generated by partially evaluating a native\n            result = await applyNativeFunction(proc.body, env);\n        } else {\n            result = await evaluate(proc.body, proc.input, env);\n        }\n        return result;\n    }\n\n    /**\n     * Partially apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure\n     */\n    function partialApplyProcedure(proc, args) {\n        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters\n        var env = createFrame(proc.environment);\n        var unboundArgs = [];\n        proc.arguments.forEach(function (param, index) {\n            var arg = args[index];\n            if (arg && arg.type === 'operator' && arg.value === '?') {\n                unboundArgs.push(param);\n            } else {\n                env.bind(param.value, arg);\n            }\n        });\n        var procedure = {\n            _jsonata_lambda: true,\n            input: proc.input,\n            environment: env,\n            arguments: unboundArgs,\n            body: proc.body\n        };\n        return procedure;\n    }\n\n    /**\n     * Partially apply native function\n     * @param {Function} native - Native function\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function\n     */\n    function partialApplyNativeFunction(native, args) {\n        // create a lambda function that wraps and invokes the native function\n        // get the list of declared arguments from the native function\n        // this has to be picked out from the toString() value\n        var sigArgs = getNativeFunctionArguments(native);\n        sigArgs = sigArgs.map(function (sigArg) {\n            return '$' + sigArg.trim();\n        });\n        var body = 'function(' + sigArgs.join(', ') + '){ _ }';\n\n        var bodyAST = parser(body);\n        bodyAST.body = native;\n\n        var partial = partialApplyProcedure(bodyAST, args);\n        return partial;\n    }\n\n    /**\n     * Apply native function\n     * @param {Object} proc - Procedure\n     * @param {Object} env - Environment\n     * @returns {*} Result of applying native function\n     */\n    async function applyNativeFunction(proc, env) {\n        var sigArgs = getNativeFunctionArguments(proc);\n        // generate the array of arguments for invoking the function - look them up in the environment\n        var args = sigArgs.map(function (sigArg) {\n            return env.lookup(sigArg.trim());\n        });\n\n        var focus = {\n            environment: env\n        };\n        var result = proc.apply(focus, args);\n        if (isPromise(result)) {\n            result = await result;\n        }\n        return result;\n    }\n\n    /**\n     * Get native function arguments\n     * @param {Function} func - Function\n     * @returns {*|Array} Native function arguments\n     */\n    function getNativeFunctionArguments(func) {\n        var signature = func.toString();\n        var sigParens = /\\(([^)]*)\\)/.exec(signature)[1]; // the contents of the parens\n        var sigArgs = sigParens.split(',');\n        return sigArgs;\n    }\n\n    /**\n     * Creates a function definition\n     * @param {Function} func - function implementation in Javascript\n     * @param {string} signature - JSONata function signature definition\n     * @returns {{implementation: *, signature: *}} function definition\n     */\n    function defineFunction(func, signature) {\n        var definition = {\n            _jsonata_function: true,\n            implementation: func\n        };\n        if(typeof signature !== 'undefined') {\n            definition.signature = parseSignature(signature);\n        }\n        return definition;\n    }\n\n\n    /**\n     * parses and evaluates the supplied expression\n     * @param {string} expr - expression to evaluate\n     * @returns {*} - result of evaluating the expression\n     */\n    async function functionEval(expr, focus) {\n        // undefined inputs always return undefined\n        if(typeof expr === 'undefined') {\n            return undefined;\n        }\n        var input = this.input;\n        if(typeof focus !== 'undefined') {\n            input = focus;\n            // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n            if(Array.isArray(input) && !isSequence(input)) {\n                input = createSequence(input);\n                input.outerWrapper = true;\n            }\n        }\n\n        try {\n            var ast = parser(expr, false);\n        } catch(err) {\n            // error parsing the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3120\",\n                value: err.message,\n                error: err\n            };\n        }\n        try {\n            var result = await evaluate(ast, input, this.environment);\n        } catch(err) {\n            // error evaluating the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3121\",\n                value:err.message,\n                error: err\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Clones an object\n     * @param {Object} arg - object to clone (deep copy)\n     * @returns {*} - the cloned object\n     */\n    function functionClone(arg) {\n        // undefined inputs always return undefined\n        if(typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return JSON.parse(fn.string(arg));\n    }\n\n    /**\n     * Create frame\n     * @param {Object} enclosingEnvironment - Enclosing environment\n     * @returns {{bind: bind, lookup: lookup}} Created frame\n     */\n    function createFrame(enclosingEnvironment) {\n        var bindings = {};\n        const newFrame = {\n            bind: function (name, value) {\n                bindings[name] = value;\n            },\n            lookup: function (name) {\n                var value;\n                if(bindings.hasOwnProperty(name)) {\n                    value = bindings[name];\n                } else if (enclosingEnvironment) {\n                    value = enclosingEnvironment.lookup(name);\n                }\n                return value;\n            },\n            timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,\n            async: enclosingEnvironment ? enclosingEnvironment.async : false,\n            isParallelCall: enclosingEnvironment ? enclosingEnvironment.isParallelCall : false,\n            global: enclosingEnvironment ? enclosingEnvironment.global : {\n                ancestry: [ null ]\n            }\n        };\n\n        if (enclosingEnvironment) {\n            var framePushCallback = enclosingEnvironment.lookup(Symbol.for('jsonata.__createFrame_push'));\n            if(framePushCallback) {\n                framePushCallback(enclosingEnvironment, newFrame);\n            }\n        }\n       \n\n        return newFrame\n    }\n\n    // Function registration\n    staticFrame.bind('sum', defineFunction(fn.sum, '<a<n>:n>'));\n    staticFrame.bind('count', defineFunction(fn.count, '<a:n>'));\n    staticFrame.bind('max', defineFunction(fn.max, '<a<n>:n>'));\n    staticFrame.bind('min', defineFunction(fn.min, '<a<n>:n>'));\n    staticFrame.bind('average', defineFunction(fn.average, '<a<n>:n>'));\n    staticFrame.bind('string', defineFunction(fn.string, '<x-b?:s>'));\n    staticFrame.bind('substring', defineFunction(fn.substring, '<s-nn?:s>'));\n    staticFrame.bind('substringBefore', defineFunction(fn.substringBefore, '<s-s:s>'));\n    staticFrame.bind('substringAfter', defineFunction(fn.substringAfter, '<s-s:s>'));\n    staticFrame.bind('lowercase', defineFunction(fn.lowercase, '<s-:s>'));\n    staticFrame.bind('uppercase', defineFunction(fn.uppercase, '<s-:s>'));\n    staticFrame.bind('length', defineFunction(fn.length, '<s-:n>'));\n    staticFrame.bind('trim', defineFunction(fn.trim, '<s-:s>'));\n    staticFrame.bind('pad', defineFunction(fn.pad, '<s-ns?:s>'));\n    staticFrame.bind('match', defineFunction(fn.match, '<s-f<s:o>n?:a<o>>'));\n    staticFrame.bind('contains', defineFunction(fn.contains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>\n    staticFrame.bind('replace', defineFunction(fn.replace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>\n    staticFrame.bind('split', defineFunction(fn.split, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>\n    staticFrame.bind('join', defineFunction(fn.join, '<a<s>s?:s>'));\n    staticFrame.bind('formatNumber', defineFunction(fn.formatNumber, '<n-so?:s>'));\n    staticFrame.bind('formatBase', defineFunction(fn.formatBase, '<n-n?:s>'));\n    staticFrame.bind('formatInteger', defineFunction(datetime.formatInteger, '<n-s:s>'));\n    staticFrame.bind('parseInteger', defineFunction(datetime.parseInteger, '<s-s:n>'));\n    staticFrame.bind('number', defineFunction(fn.number, '<(nsb)-:n>'));\n    staticFrame.bind('floor', defineFunction(fn.floor, '<n-:n>'));\n    staticFrame.bind('ceil', defineFunction(fn.ceil, '<n-:n>'));\n    staticFrame.bind('round', defineFunction(fn.round, '<n-n?:n>'));\n    staticFrame.bind('abs', defineFunction(fn.abs, '<n-:n>'));\n    staticFrame.bind('sqrt', defineFunction(fn.sqrt, '<n-:n>'));\n    staticFrame.bind('power', defineFunction(fn.power, '<n-n:n>'));\n    staticFrame.bind('random', defineFunction(fn.random, '<:n>'));\n    staticFrame.bind('boolean', defineFunction(fn.boolean, '<x-:b>'));\n    staticFrame.bind('not', defineFunction(fn.not, '<x-:b>'));\n    staticFrame.bind('map', defineFunction(fn.map, '<af>'));\n    staticFrame.bind('zip', defineFunction(fn.zip, '<a+>'));\n    staticFrame.bind('filter', defineFunction(fn.filter, '<af>'));\n    staticFrame.bind('single', defineFunction(fn.single, '<af?>'));\n    staticFrame.bind('reduce', defineFunction(fn.foldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>\n    staticFrame.bind('sift', defineFunction(fn.sift, '<o-f?:o>'));\n    staticFrame.bind('keys', defineFunction(fn.keys, '<x-:a<s>>'));\n    staticFrame.bind('lookup', defineFunction(fn.lookup, '<x-s:x>'));\n    staticFrame.bind('append', defineFunction(fn.append, '<xx:a>'));\n    staticFrame.bind('exists', defineFunction(fn.exists, '<x:b>'));\n    staticFrame.bind('spread', defineFunction(fn.spread, '<x-:a<o>>'));\n    staticFrame.bind('merge', defineFunction(fn.merge, '<a<o>:o>'));\n    staticFrame.bind('reverse', defineFunction(fn.reverse, '<a:a>'));\n    staticFrame.bind('each', defineFunction(fn.each, '<o-f:a>'));\n    staticFrame.bind('error', defineFunction(fn.error, '<s?:x>'));\n    staticFrame.bind('assert', defineFunction(fn.assert, '<bs?:x>'));\n    staticFrame.bind('type', defineFunction(fn.type, '<x:s>'));\n    staticFrame.bind('sort', defineFunction(fn.sort, '<af?:a>'));\n    staticFrame.bind('shuffle', defineFunction(fn.shuffle, '<a:a>'));\n    staticFrame.bind('distinct', defineFunction(fn.distinct, '<x:x>'));\n    staticFrame.bind('base64encode', defineFunction(fn.base64encode, '<s-:s>'));\n    staticFrame.bind('base64decode', defineFunction(fn.base64decode, '<s-:s>'));\n    staticFrame.bind('encodeUrlComponent', defineFunction(fn.encodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('encodeUrl', defineFunction(fn.encodeUrl, '<s-:s>'));\n    staticFrame.bind('decodeUrlComponent', defineFunction(fn.decodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('decodeUrl', defineFunction(fn.decodeUrl, '<s-:s>'));\n    staticFrame.bind('eval', defineFunction(functionEval, '<sx?:x>'));\n    staticFrame.bind('toMillis', defineFunction(datetime.toMillis, '<s-s?:n>'));\n    staticFrame.bind('fromMillis', defineFunction(datetime.fromMillis, '<n-s?s?:s>'));\n    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));\n\n    /**\n     * Error codes\n     *\n     * Sxxxx    - Static errors (compile time)\n     * Txxxx    - Type errors\n     * Dxxxx    - Dynamic errors (evaluate time)\n     *  01xx    - tokenizer\n     *  02xx    - parser\n     *  03xx    - regex parser\n     *  04xx    - function signature parser/evaluator\n     *  10xx    - evaluator\n     *  20xx    - operators\n     *  3xxx    - functions (blocks of 10 for each function)\n     */\n    var errorCodes = {\n        \"S0101\": \"String literal must be terminated by a matching quote\",\n        \"S0102\": \"Number out of range: {{token}}\",\n        \"S0103\": \"Unsupported escape sequence: \\\\{{token}}\",\n        \"S0104\": \"The escape sequence \\\\u must be followed by 4 hex digits\",\n        \"S0105\": \"Quoted property name must be terminated with a backquote (`)\",\n        \"S0106\": \"Comment has no closing tag\",\n        \"S0201\": \"Syntax error: {{token}}\",\n        \"S0202\": \"Expected {{value}}, got {{token}}\",\n        \"S0203\": \"Expected {{value}} before end of expression\",\n        \"S0204\": \"Unknown operator: {{token}}\",\n        \"S0205\": \"Unexpected token: {{token}}\",\n        \"S0206\": \"Unknown expression type: {{token}}\",\n        \"S0207\": \"Unexpected end of expression\",\n        \"S0208\": \"Parameter {{value}} of function definition must be a variable name (start with $)\",\n        \"S0209\": \"A predicate cannot follow a grouping expression in a step\",\n        \"S0210\": \"Each step can only have one grouping expression\",\n        \"S0211\": \"The symbol {{token}} cannot be used as a unary operator\",\n        \"S0212\": \"The left side of := must be a variable name (start with $)\",\n        \"S0213\": \"The literal value {{value}} cannot be used as a step within a path expression\",\n        \"S0214\": \"The right side of {{token}} must be a variable name (start with $)\",\n        \"S0215\": \"A context variable binding must precede any predicates on a step\",\n        \"S0216\": \"A context variable binding must precede the 'order-by' clause on a step\",\n        \"S0217\": \"The object representing the 'parent' cannot be derived from this expression\",\n        \"S0301\": \"Empty regular expressions are not allowed\",\n        \"S0302\": \"No terminating / in regular expression\",\n        \"S0402\": \"Choice groups containing parameterized types are not supported\",\n        \"S0401\": \"Type parameters can only be applied to functions and arrays\",\n        \"S0500\": \"Attempted to evaluate an expression containing syntax error(s)\",\n        \"T0410\": \"Argument {{index}} of function {{token}} does not match function signature\",\n        \"T0411\": \"Context value is not a compatible type with argument {{index}} of function {{token}}\",\n        \"T0412\": \"Argument {{index}} of function {{token}} must be an array of {{type}}\",\n        \"D1001\": \"Number out of range: {{value}}\",\n        \"D1002\": \"Cannot negate a non-numeric value: {{value}}\",\n        \"T1003\": \"Key in object structure must evaluate to a string; got: {{value}}\",\n        \"D1004\": \"Regular expression matches zero length string\",\n        \"T1005\": \"Attempted to invoke a non-function. Did you mean ${{{token}}}?\",\n        \"T1006\": \"Attempted to invoke a non-function\",\n        \"T1007\": \"Attempted to partially apply a non-function. Did you mean ${{{token}}}?\",\n        \"T1008\": \"Attempted to partially apply a non-function\",\n        \"D1009\": \"Multiple key definitions evaluate to same key: {{value}}\",\n        \"D1010\": \"Attempted to access the Javascript object prototype\", // Javascript specific \n        \"T1010\": \"The matcher function argument passed to function {{token}} does not return the correct object structure\",\n        \"T2001\": \"The left side of the {{token}} operator must evaluate to a number\",\n        \"T2002\": \"The right side of the {{token}} operator must evaluate to a number\",\n        \"T2003\": \"The left side of the range operator (..) must evaluate to an integer\",\n        \"T2004\": \"The right side of the range operator (..) must evaluate to an integer\",\n        \"D2005\": \"The left side of := must be a variable name (start with $)\",  // defunct - replaced by S0212 parser error\n        \"T2006\": \"The right side of the function application operator ~> must be a function\",\n        \"T2007\": \"Type mismatch when comparing values {{value}} and {{value2}} in order-by clause\",\n        \"T2008\": \"The expressions within an order-by clause must evaluate to numeric or string values\",\n        \"T2009\": \"The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type\",\n        \"T2010\": \"The expressions either side of operator {{token}} must evaluate to numeric or string values\",\n        \"T2011\": \"The insert/update clause of the transform expression must evaluate to an object: {{value}}\",\n        \"T2012\": \"The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}\",\n        \"T2013\": \"The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.\",\n        \"D2014\": \"The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.\",\n        \"D3001\": \"Attempting to invoke string function on Infinity or NaN\",\n        \"D3010\": \"Second argument of replace function cannot be an empty string\",\n        \"D3011\": \"Fourth argument of replace function must evaluate to a positive number\",\n        \"D3012\": \"Attempted to replace a matched string with a non-string value\",\n        \"D3020\": \"Third argument of split function must evaluate to a positive number\",\n        \"D3030\": \"Unable to cast value to a number: {{value}}\",\n        \"D3040\": \"Third argument of match function must evaluate to a positive number\",\n        \"D3050\": \"The second argument of reduce function must be a function with at least two arguments\",\n        \"D3060\": \"The sqrt function cannot be applied to a negative number: {{value}}\",\n        \"D3061\": \"The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}\",\n        \"D3070\": \"The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function\",\n        \"D3080\": \"The picture string must only contain a maximum of two sub-pictures\",\n        \"D3081\": \"The sub-picture must not contain more than one instance of the 'decimal-separator' character\",\n        \"D3082\": \"The sub-picture must not contain more than one instance of the 'percent' character\",\n        \"D3083\": \"The sub-picture must not contain more than one instance of the 'per-mille' character\",\n        \"D3084\": \"The sub-picture must not contain both a 'percent' and a 'per-mille' character\",\n        \"D3085\": \"The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'\",\n        \"D3086\": \"The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character\",\n        \"D3087\": \"The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character\",\n        \"D3088\": \"The sub-picture must not contain a 'grouping-separator' at the end of the integer part\",\n        \"D3089\": \"The sub-picture must not contain two adjacent instances of the 'grouping-separator' character\",\n        \"D3090\": \"The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'\",\n        \"D3091\": \"The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'\",\n        \"D3092\": \"A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'\",\n        \"D3093\": \"The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'\",\n        \"D3100\": \"The radix of the formatBase function must be between 2 and 36.  It was given {{value}}\",\n        \"D3110\": \"The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}\",\n        \"D3120\": \"Syntax error in expression passed to function eval: {{value}}\",\n        \"D3121\": \"Dynamic error evaluating the expression passed to function eval: {{value}}\",\n        \"D3130\": \"Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation\",\n        \"D3131\": \"In a decimal digit pattern, all digits must be from the same decimal group\",\n        \"D3132\": \"Unknown component specifier {{value}} in date/time picture string\",\n        \"D3133\": \"The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}\",\n        \"D3134\": \"The timezone integer format specifier cannot have more than four digits\",\n        \"D3135\": \"No matching closing bracket ']' in date/time picture string\",\n        \"D3136\": \"The date/time picture string is missing specifiers required to parse the timestamp\",\n        \"D3137\": \"{{{message}}}\",\n        \"D3138\": \"The $single() function expected exactly 1 matching result.  Instead it matched more.\",\n        \"D3139\": \"The $single() function expected exactly 1 matching result.  Instead it matched 0.\",\n        \"D3140\": \"Malformed URL passed to ${{{functionName}}}(): {{value}}\",\n        \"D3141\": \"{{{message}}}\"\n    };\n\n    /**\n     * lookup a message template from the catalog and substitute the inserts.\n     * Populates `err.message` with the substituted message. Leaves `err.message`\n     * untouched if code lookup fails.\n     * @param {string} err - error code to lookup\n     * @returns {undefined} - `err` is modified in place\n     */\n    function populateMessage(err) {\n        var template = errorCodes[err.code];\n        if(typeof template !== 'undefined') {\n            // if there are any handlebars, replace them with the field references\n            // triple braces - replace with value\n            // double braces - replace with json stringified value\n            var message = template.replace(/\\{\\{\\{([^}]+)}}}/g, function() {\n                return err[arguments[1]];\n            });\n            message = message.replace(/\\{\\{([^}]+)}}/g, function() {\n                return JSON.stringify(err[arguments[1]]);\n            });\n            err.message = message;\n        }\n        // Otherwise retain the original `err.message`\n    }\n\n    /**\n     * JSONata\n     * @param {Object} expr - JSONata expression\n     * @param {Object} options\n     * @param {boolean} options.recover: attempt to recover on parse error\n     * @param {Function} options.RegexEngine: RegEx class constructor to use\n     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n     */\n    function jsonata(expr, options) {\n        var ast;\n        var errors;\n        try {\n            ast = parser(expr, options && options.recover);\n            errors = ast.errors;\n            delete ast.errors;\n        } catch(err) {\n            // insert error message into structure\n            populateMessage(err); // possible side-effects on `err`\n            throw err;\n        }\n        var environment = createFrame(staticFrame);\n\n        var timestamp = new Date(); // will be overridden on each call to evalute()\n        environment.bind('now', defineFunction(function(picture, timezone) {\n            return datetime.fromMillis(timestamp.getTime(), picture, timezone);\n        }, '<s?s?:s>'));\n        environment.bind('millis', defineFunction(function() {\n            return timestamp.getTime();\n        }, '<:n>'));\n\n        if(options && options.RegexEngine) {\n            jsonata.RegexEngine = options.RegexEngine;\n        } else {\n            jsonata.RegexEngine = RegExp;\n        }\n\n        return {\n            evaluate: async function (input, bindings, callback) {\n                // throw if the expression compiled with syntax errors\n                if(typeof errors !== 'undefined') {\n                    var err = {\n                        code: 'S0500',\n                        position: 0\n                    };\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n\n                if (typeof bindings !== 'undefined') {\n                    var exec_env;\n                    // the variable bindings have been passed in - create a frame to hold these\n                    exec_env = createFrame(environment);\n                    for (var v in bindings) {\n                        exec_env.bind(v, bindings[v]);\n                    }\n                } else {\n                    exec_env = environment;\n                }\n                // put the input document into the environment as the root object\n                exec_env.bind('$', input);\n\n                // capture the timestamp and put it in the execution environment\n                // the $now() and $millis() functions will return this value - whenever it is called\n                timestamp = new Date();\n                exec_env.timestamp = timestamp;\n\n                // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n                if(Array.isArray(input) && !isSequence(input)) {\n                    input = createSequence(input);\n                    input.outerWrapper = true;\n                }\n\n                var it;\n                try {\n                    it = await evaluate(ast, input, exec_env);\n                    if (typeof callback === \"function\") {\n                        callback(null, it);\n                    }\n                    return it;\n                } catch (err) {\n                    // insert error message into structure\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n            },\n            assign: function (name, value) {\n                environment.bind(name, value);\n            },\n            registerFunction: function(name, implementation, signature) {\n                var func = defineFunction(implementation, signature);\n                environment.bind(name, func);\n            },\n            ast: function() {\n                return ast;\n            },\n            errors: function() {\n                return errors;\n            }\n        };\n    }\n\n    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead\n\n    return jsonata;\n\n})();\n\nmodule.exports = jsonata;\n\n},{\"./datetime\":1,\"./functions\":2,\"./parser\":4,\"./signature\":5,\"./utils\":6}],4:[function(require,module,exports){\n/**\n * \u00A9 Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar parseSignature = require('./signature');\n\nconst parser = (() => {\n    'use strict';\n\n    var operators = {\n        '.': 75,\n        '[': 80,\n        ']': 0,\n        '{': 70,\n        '}': 0,\n        '(': 80,\n        ')': 0,\n        ',': 0,\n        '@': 80,\n        '#': 80,\n        ';': 80,\n        ':': 80,\n        '?': 20,\n        '+': 50,\n        '-': 50,\n        '*': 60,\n        '/': 60,\n        '%': 60,\n        '|': 20,\n        '=': 40,\n        '<': 40,\n        '>': 40,\n        '^': 40,\n        '**': 60,\n        '..': 20,\n        ':=': 10,\n        '!=': 40,\n        '<=': 40,\n        '>=': 40,\n        '~>': 40,\n        '?:': 40,\n        '??': 40,\n        'and': 30,\n        'or': 25,\n        'in': 40,\n        '&': 50,\n        '!': 0,   // not an operator, but needed as a stop character for name tokens\n        '~': 0   // not an operator, but needed as a stop character for name tokens\n    };\n\n    var escapes = {  // JSON string escape sequences - see json.org\n        '\"': '\"',\n        '\\\\': '\\\\',\n        '/': '/',\n        'b': '\\b',\n        'f': '\\f',\n        'n': '\\n',\n        'r': '\\r',\n        't': '\\t'\n    };\n\n    // Tokenizer (lexer) - invoked by the parser to return one token at a time\n    var tokenizer = function (path) {\n        var position = 0;\n        var length = path.length;\n\n        var create = function (type, value) {\n            var obj = {type: type, value: value, position: position};\n            return obj;\n        };\n\n        var scanRegex = function () {\n            // the prefix '/' will have been previously scanned. Find the end of the regex.\n            // search for closing '/' ignoring any that are escaped, or within brackets\n            var start = position;\n            var depth = 0;\n            var pattern;\n            var flags;\n\n            var isClosingSlash = function (position) {\n                if (path.charAt(position) === '/' && depth === 0) {\n                    var backslashCount = 0;\n                    while (path.charAt(position - (backslashCount + 1)) === '\\\\') {\n                        backslashCount++;\n                    }\n                    if (backslashCount % 2 === 0) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n            while (position < length) {\n                var currentChar = path.charAt(position);\n                if (isClosingSlash(position)) {\n                    // end of regex found\n                    pattern = path.substring(start, position);\n                    if (pattern === '') {\n                        throw {\n                            code: \"S0301\",\n                            stack: (new Error()).stack,\n                            position: position\n                        };\n                    }\n                    position++;\n                    currentChar = path.charAt(position);\n                    // flags\n                    start = position;\n                    while (currentChar === 'i' || currentChar === 'm') {\n                        position++;\n                        currentChar = path.charAt(position);\n                    }\n                    flags = path.substring(start, position) + 'g';\n                    return new RegExp(pattern, flags);\n                }\n                if ((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\\\') {\n                    depth++;\n                }\n                if ((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\\\') {\n                    depth--;\n                }\n\n                position++;\n            }\n            throw {\n                code: \"S0302\",\n                stack: (new Error()).stack,\n                position: position\n            };\n        };\n\n        var next = function (prefix) {\n            if (position >= length) return null;\n            var currentChar = path.charAt(position);\n            // skip whitespace\n            while (position < length && ' \\t\\n\\r\\v'.indexOf(currentChar) > -1) {\n                position++;\n                currentChar = path.charAt(position);\n            }\n            // skip comments\n            if (currentChar === '/' && path.charAt(position + 1) === '*') {\n                var commentStart = position;\n                position += 2;\n                currentChar = path.charAt(position);\n                while (!(currentChar === '*' && path.charAt(position + 1) === '/')) {\n                    currentChar = path.charAt(++position);\n                    if (position >= length) {\n                        // no closing tag\n                        throw {\n                            code: \"S0106\",\n                            stack: (new Error()).stack,\n                            position: commentStart\n                        };\n                    }\n                }\n                position += 2;\n                currentChar = path.charAt(position);\n                return next(prefix); // need this to swallow any following whitespace\n            }\n            // test for regex\n            if (prefix !== true && currentChar === '/') {\n                position++;\n                return create('regex', scanRegex());\n            }\n            // handle double-char operators\n            if (currentChar === '.' && path.charAt(position + 1) === '.') {\n                // double-dot .. range operator\n                position += 2;\n                return create('operator', '..');\n            }\n            if (currentChar === ':' && path.charAt(position + 1) === '=') {\n                // := assignment\n                position += 2;\n                return create('operator', ':=');\n            }\n            if (currentChar === '!' && path.charAt(position + 1) === '=') {\n                // !=\n                position += 2;\n                return create('operator', '!=');\n            }\n            if (currentChar === '>' && path.charAt(position + 1) === '=') {\n                // >=\n                position += 2;\n                return create('operator', '>=');\n            }\n            if (currentChar === '<' && path.charAt(position + 1) === '=') {\n                // <=\n                position += 2;\n                return create('operator', '<=');\n            }\n            if (currentChar === '*' && path.charAt(position + 1) === '*') {\n                // **  descendant wildcard\n                position += 2;\n                return create('operator', '**');\n            }\n            if (currentChar === '~' && path.charAt(position + 1) === '>') {\n                // ~>  chain function\n                position += 2;\n                return create('operator', '~>');\n            }\n            if (currentChar === '?' && path.charAt(position + 1) === ':') {\n                // ?: default / elvis operator\n                position += 2;\n                return create('operator', '?:');\n            }\n            if (currentChar === '?' && path.charAt(position + 1) === '?') {\n                // ?? coalescing operator\n                position += 2;\n                return create('operator', '??');\n            }\n            // test for single char operators\n            if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {\n                position++;\n                return create('operator', currentChar);\n            }\n            // test for string literals\n            if (currentChar === '\"' || currentChar === \"'\") {\n                var quoteType = currentChar;\n                // double quoted string literal - find end of string\n                position++;\n                var qstr = \"\";\n                while (position < length) {\n                    currentChar = path.charAt(position);\n                    if (currentChar === '\\\\') { // escape sequence\n                        position++;\n                        currentChar = path.charAt(position);\n                        if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {\n                            qstr += escapes[currentChar];\n                        } else if (currentChar === 'u') {\n                            // \\u should be followed by 4 hex digits\n                            var octets = path.substr(position + 1, 4);\n                            if (/^[0-9a-fA-F]+$/.test(octets)) {\n                                var codepoint = parseInt(octets, 16);\n                                qstr += String.fromCharCode(codepoint);\n                                position += 4;\n                            } else {\n                                throw {\n                                    code: \"S0104\",\n                                    stack: (new Error()).stack,\n                                    position: position\n                                };\n                            }\n                        } else {\n                            // illegal escape sequence\n                            throw {\n                                code: \"S0103\",\n                                stack: (new Error()).stack,\n                                position: position,\n                                token: currentChar\n                            };\n\n                        }\n                    } else if (currentChar === quoteType) {\n                        position++;\n                        return create('string', qstr);\n                    } else {\n                        qstr += currentChar;\n                    }\n                    position++;\n                }\n                throw {\n                    code: \"S0101\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for numbers\n            var numregex = /^-?(0|([1-9][0-9]*))(\\.[0-9]+)?([Ee][-+]?[0-9]+)?/;\n            var match = numregex.exec(path.substring(position));\n            if (match !== null) {\n                var num = parseFloat(match[0]);\n                if (!isNaN(num) && isFinite(num)) {\n                    position += match[0].length;\n                    return create('number', num);\n                } else {\n                    throw {\n                        code: \"S0102\",\n                        stack: (new Error()).stack,\n                        position: position,\n                        token: match[0]\n                    };\n                }\n            }\n            // test for quoted names (backticks)\n            var name;\n            if (currentChar === '`') {\n                // scan for closing quote\n                position++;\n                var end = path.indexOf('`', position);\n                if (end !== -1) {\n                    name = path.substring(position, end);\n                    position = end + 1;\n                    return create('name', name);\n                }\n                position = length;\n                throw {\n                    code: \"S0105\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for names\n            var i = position;\n            var ch;\n            for (; ;) {\n                ch = path.charAt(i);\n                if (i === length || ' \\t\\n\\r\\v'.indexOf(ch) > -1 || Object.prototype.hasOwnProperty.call(operators, ch)) {\n                    if (path.charAt(position) === '$') {\n                        // variable reference\n                        name = path.substring(position + 1, i);\n                        position = i;\n                        return create('variable', name);\n                    } else {\n                        name = path.substring(position, i);\n                        position = i;\n                        switch (name) {\n                            case 'or':\n                            case 'in':\n                            case 'and':\n                                return create('operator', name);\n                            case 'true':\n                                return create('value', true);\n                            case 'false':\n                                return create('value', false);\n                            case 'null':\n                                return create('value', null);\n                            default:\n                                if (position === length && name === '') {\n                                    // whitespace at end of input\n                                    return null;\n                                }\n                                return create('name', name);\n                        }\n                    }\n                } else {\n                    i++;\n                }\n            }\n        };\n\n        return next;\n    };\n\n    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.\n    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html\n    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6\n\n    var parser = function (source, recover) {\n        var node;\n        var lexer;\n\n        var symbol_table = {};\n        var errors = [];\n\n        var remainingTokens = function () {\n            var remaining = [];\n            if (node.id !== '(end)') {\n                remaining.push({type: node.type, value: node.value, position: node.position});\n            }\n            var nxt = lexer();\n            while (nxt !== null) {\n                remaining.push(nxt);\n                nxt = lexer();\n            }\n            return remaining;\n        };\n\n        var base_symbol = {\n            nud: function () {\n                // error - symbol has been invoked as a unary operator\n                var err = {\n                    code: 'S0211',\n                    token: this.value,\n                    position: this.position\n                };\n\n                if (recover) {\n                    err.remaining = remainingTokens();\n                    err.type = 'error';\n                    errors.push(err);\n                    return err;\n                } else {\n                    err.stack = (new Error()).stack;\n                    throw err;\n                }\n            }\n        };\n\n        var symbol = function (id, bp) {\n            var s = symbol_table[id];\n            bp = bp || 0;\n            if (s) {\n                if (bp >= s.lbp) {\n                    s.lbp = bp;\n                }\n            } else {\n                s = Object.create(base_symbol);\n                s.id = s.value = id;\n                s.lbp = bp;\n                symbol_table[id] = s;\n            }\n            return s;\n        };\n\n        var handleError = function (err) {\n            if (recover) {\n                // tokenize the rest of the buffer and add it to an error token\n                err.remaining = remainingTokens();\n                errors.push(err);\n                var symbol = symbol_table[\"(error)\"];\n                node = Object.create(symbol);\n                node.error = err;\n                node.type = \"(error)\";\n                return node;\n            } else {\n                err.stack = (new Error()).stack;\n                throw err;\n            }\n        };\n\n        var advance = function (id, infix) {\n            if (id && node.id !== id) {\n                var code;\n                if (node.id === '(end)') {\n                    // unexpected end of buffer\n                    code = \"S0203\";\n                } else {\n                    code = \"S0202\";\n                }\n                var err = {\n                    code: code,\n                    position: node.position,\n                    token: node.value,\n                    value: id\n                };\n                return handleError(err);\n            }\n            var next_token = lexer(infix);\n            if (next_token === null) {\n                node = symbol_table[\"(end)\"];\n                node.position = source.length;\n                return node;\n            }\n            var value = next_token.value;\n            var type = next_token.type;\n            var symbol;\n            switch (type) {\n                case 'name':\n                case 'variable':\n                    symbol = symbol_table[\"(name)\"];\n                    break;\n                case 'operator':\n                    symbol = symbol_table[value];\n                    if (!symbol) {\n                        return handleError({\n                            code: \"S0204\",\n                            stack: (new Error()).stack,\n                            position: next_token.position,\n                            token: value\n                        });\n                    }\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                    symbol = symbol_table[\"(literal)\"];\n                    break;\n                case 'regex':\n                    type = \"regex\";\n                    symbol = symbol_table[\"(regex)\"];\n                    break;\n                /* istanbul ignore next */\n                default:\n                    return handleError({\n                        code: \"S0205\",\n                        stack: (new Error()).stack,\n                        position: next_token.position,\n                        token: value\n                    });\n            }\n\n            node = Object.create(symbol);\n            node.value = value;\n            node.type = type;\n            node.position = next_token.position;\n            return node;\n        };\n\n        // Pratt's algorithm\n        var expression = function (rbp) {\n            var left;\n            var t = node;\n            advance(null, true);\n            left = t.nud();\n            while (rbp < node.lbp) {\n                t = node;\n                advance();\n                left = t.led(left);\n            }\n            return left;\n        };\n\n        var terminal = function (id) {\n            var s = symbol(id, 0);\n            s.nud = function () {\n                return this;\n            };\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // left associative\n        var infix = function (id, bp, led) {\n            var bindingPower = bp || operators[id];\n            var s = symbol(id, bindingPower);\n            s.led = led || function (left) {\n                this.lhs = left;\n                this.rhs = expression(bindingPower);\n                this.type = \"binary\";\n                return this;\n            };\n            return s;\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // right associative\n        var infixr = function (id, bp, led) {\n            var s = symbol(id, bp);\n            s.led = led;\n            return s;\n        };\n\n        // match prefix operators\n        // <operator> <expression>\n        var prefix = function (id, nud) {\n            var s = symbol(id);\n            s.nud = nud || function () {\n                this.expression = expression(70);\n                this.type = \"unary\";\n                return this;\n            };\n            return s;\n        };\n\n        terminal(\"(end)\");\n        terminal(\"(name)\");\n        terminal(\"(literal)\");\n        terminal(\"(regex)\");\n        symbol(\":\");\n        symbol(\";\");\n        symbol(\",\");\n        symbol(\")\");\n        symbol(\"]\");\n        symbol(\"}\");\n        symbol(\"..\"); // range operator\n        infix(\".\"); // map operator\n        infix(\"+\"); // numeric addition\n        infix(\"-\"); // numeric subtraction\n        infix(\"*\"); // numeric multiplication\n        infix(\"/\"); // numeric division\n        infix(\"%\"); // numeric modulus\n        infix(\"=\"); // equality\n        infix(\"<\"); // less than\n        infix(\">\"); // greater than\n        infix(\"!=\"); // not equal to\n        infix(\"<=\"); // less than or equal\n        infix(\">=\"); // greater than or equal\n        infix(\"&\"); // string concatenation\n        infix(\"and\"); // Boolean AND\n        infix(\"or\"); // Boolean OR\n        infix(\"in\"); // is member of array\n        terminal(\"and\"); // the 'keywords' can also be used as terminals (field names)\n        terminal(\"or\"); //\n        terminal(\"in\"); //\n        prefix(\"-\"); // unary numeric negation\n        infix(\"~>\"); // function application\n\n        // coalescing operator\n        infix(\"??\", operators['??'], function (left) {\n            this.type = 'condition';\n            this.condition = {\n                type: 'function',\n                value: '(',\n                procedure: { type: 'variable', value: 'exists' },\n                arguments: [left]\n            };\n            this.then = left;\n            this.else = expression(0);\n            return this;\n        });\n\n        infixr(\"(error)\", 10, function (left) {\n            this.lhs = left;\n\n            this.error = node.error;\n            this.remaining = remainingTokens();\n            this.type = 'error';\n            return this;\n        });\n\n        // field wildcard (single level)\n        prefix('*', function () {\n            this.type = \"wildcard\";\n            return this;\n        });\n\n        // descendant wildcard (multi-level)\n        prefix('**', function () {\n            this.type = \"descendant\";\n            return this;\n        });\n\n        // parent operator\n        prefix('%', function () {\n            this.type = \"parent\";\n            return this;\n        });\n\n        // function invocation\n        infix(\"(\", operators['('], function (left) {\n            // left is is what we are trying to invoke\n            this.procedure = left;\n            this.type = 'function';\n            this.arguments = [];\n            if (node.id !== ')') {\n                for (; ;) {\n                    if (node.type === 'operator' && node.id === '?') {\n                        // partial function application\n                        this.type = 'partial';\n                        this.arguments.push(node);\n                        advance('?');\n                    } else {\n                        this.arguments.push(expression(0));\n                    }\n                    if (node.id !== ',') break;\n                    advance(',');\n                }\n            }\n            advance(\")\", true);\n            // if the name of the function is 'function' or \u03BB, then this is function definition (lambda function)\n            if (left.type === 'name' && (left.value === 'function' || left.value === '\\u03BB')) {\n                // all of the args must be VARIABLE tokens\n                this.arguments.forEach(function (arg, index) {\n                    if (arg.type !== 'variable') {\n                        return handleError({\n                            code: \"S0208\",\n                            stack: (new Error()).stack,\n                            position: arg.position,\n                            token: arg.value,\n                            value: index + 1\n                        });\n                    }\n                });\n                this.type = 'lambda';\n                // is the next token a '<' - if so, parse the function signature\n                if (node.id === '<') {\n                    var sigPos = node.position;\n                    var depth = 1;\n                    var sig = '<';\n                    while (depth > 0 && node.id !== '{' && node.id !== '(end)') {\n                        var tok = advance();\n                        if (tok.id === '>') {\n                            depth--;\n                        } else if (tok.id === '<') {\n                            depth++;\n                        }\n                        sig += tok.value;\n                    }\n                    advance('>');\n                    try {\n                        this.signature = parseSignature(sig);\n                    } catch (err) {\n                        // insert the position into this error\n                        err.position = sigPos + err.offset;\n                        return handleError(err);\n                    }\n                }\n                // parse the function body\n                advance('{');\n                this.body = expression(0);\n                advance('}');\n            }\n            return this;\n        });\n\n        // parenthesis - block expression\n        prefix(\"(\", function () {\n            var expressions = [];\n            while (node.id !== \")\") {\n                expressions.push(expression(0));\n                if (node.id !== \";\") {\n                    break;\n                }\n                advance(\";\");\n            }\n            advance(\")\", true);\n            this.type = 'block';\n            this.expressions = expressions;\n            return this;\n        });\n\n        // array constructor\n        prefix(\"[\", function () {\n            var a = [];\n            if (node.id !== \"]\") {\n                for (; ;) {\n                    var item = expression(0);\n                    if (node.id === \"..\") {\n                        // range operator\n                        var range = {type: \"binary\", value: \"..\", position: node.position, lhs: item};\n                        advance(\"..\");\n                        range.rhs = expression(0);\n                        item = range;\n                    }\n                    a.push(item);\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"]\", true);\n            this.expressions = a;\n            this.type = \"unary\";\n            return this;\n        });\n\n        // filter - predicate or array index\n        infix(\"[\", operators['['], function (left) {\n            if (node.id === \"]\") {\n                // empty predicate means maintain singleton arrays in the output\n                var step = left;\n                while (step && step.type === 'binary' && step.value === '[') {\n                    step = step.lhs;\n                }\n                step.keepArray = true;\n                advance(\"]\");\n                return left;\n            } else {\n                this.lhs = left;\n                this.rhs = expression(operators[']']);\n                this.type = 'binary';\n                advance(\"]\", true);\n                return this;\n            }\n        });\n\n        // order-by\n        infix(\"^\", operators['^'], function (left) {\n            advance(\"(\");\n            var terms = [];\n            for (; ;) {\n                var term = {\n                    descending: false\n                };\n                if (node.id === \"<\") {\n                    // ascending sort\n                    advance(\"<\");\n                } else if (node.id === \">\") {\n                    // descending sort\n                    term.descending = true;\n                    advance(\">\");\n                } else {\n                    //unspecified - default to ascending\n                }\n                term.expression = expression(0);\n                terms.push(term);\n                if (node.id !== \",\") {\n                    break;\n                }\n                advance(\",\");\n            }\n            advance(\")\");\n            this.lhs = left;\n            this.rhs = terms;\n            this.type = 'binary';\n            return this;\n        });\n\n        var objectParser = function (left) {\n            var a = [];\n            if (node.id !== \"}\") {\n                for (; ;) {\n                    var n = expression(0);\n                    advance(\":\");\n                    var v = expression(0);\n                    a.push([n, v]); // holds an array of name/value expression pairs\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"}\", true);\n            if (typeof left === 'undefined') {\n                // NUD - unary prefix form\n                this.lhs = a;\n                this.type = \"unary\";\n            } else {\n                // LED - binary infix form\n                this.lhs = left;\n                this.rhs = a;\n                this.type = 'binary';\n            }\n            return this;\n        };\n\n        // object constructor\n        prefix(\"{\", objectParser);\n\n        // object grouping\n        infix(\"{\", operators['{'], objectParser);\n\n        // bind variable\n        infixr(\":=\", operators[':='], function (left) {\n            if (left.type !== 'variable') {\n                return handleError({\n                    code: \"S0212\",\n                    stack: (new Error()).stack,\n                    position: left.position,\n                    token: left.value\n                });\n            }\n            this.lhs = left;\n            this.rhs = expression(operators[':='] - 1); // subtract 1 from bindingPower for right associative operators\n            this.type = \"binary\";\n            return this;\n        });\n\n        // focus variable bind\n        infix(\"@\", operators['@'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['@']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"@\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // index (position) variable bind\n        infix(\"#\", operators['#'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['#']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"#\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // if/then/else ternary operator ?:\n        infix(\"?\", operators['?'], function (left) {\n            this.type = 'condition';\n            this.condition = left;\n            this.then = expression(0);\n            if (node.id === ':') {\n                // else condition\n                advance(\":\");\n                this.else = expression(0);\n            }\n            return this;\n        });\n\n        // elvis/default operator\n        infix(\"?:\", operators['?:'], function (left) {\n            this.type = 'condition';\n            this.condition = left;\n            this.then = left;\n            this.else = expression(0);\n            return this;\n        });\n\n        // object transformer\n        prefix(\"|\", function () {\n            this.type = 'transform';\n            this.pattern = expression(0);\n            advance('|');\n            this.update = expression(0);\n            if (node.id === ',') {\n                advance(',');\n                this.delete = expression(0);\n            }\n            advance('|');\n            return this;\n        });\n\n        // tail call optimization\n        // this is invoked by the post parser to analyse lambda functions to see\n        // if they make a tail call.  If so, it is replaced by a thunk which will\n        // be invoked by the trampoline loop during function application.\n        // This enables tail-recursive functions to be written without growing the stack\n        var tailCallOptimize = function (expr) {\n            var result;\n            if (expr.type === 'function' && !expr.predicate) {\n                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};\n                thunk.body = expr;\n                result = thunk;\n            } else if (expr.type === 'condition') {\n                // analyse both branches\n                expr.then = tailCallOptimize(expr.then);\n                if (typeof expr.else !== 'undefined') {\n                    expr.else = tailCallOptimize(expr.else);\n                }\n                result = expr;\n            } else if (expr.type === 'block') {\n                // only the last expression in the block\n                var length = expr.expressions.length;\n                if (length > 0) {\n                    expr.expressions[length - 1] = tailCallOptimize(expr.expressions[length - 1]);\n                }\n                result = expr;\n            } else {\n                result = expr;\n            }\n            return result;\n        };\n\n        var ancestorLabel = 0;\n        var ancestorIndex = 0;\n        var ancestry = [];\n\n        var seekParent = function (node, slot) {\n            switch (node.type) {\n                case 'name':\n                case 'wildcard':\n                    slot.level--;\n                    if(slot.level === 0) {\n                        if (typeof node.ancestor === 'undefined') {\n                            node.ancestor = slot;\n                        } else {\n                            // reuse the existing label\n                            ancestry[slot.index].slot.label = node.ancestor.label;\n                            node.ancestor = slot;\n                        }\n                        node.tuple = true;\n                    }\n                    break;\n                case 'parent':\n                    slot.level++;\n                    break;\n                case 'block':\n                    // look in last expression in the block\n                    if(node.expressions.length > 0) {\n                        node.tuple = true;\n                        slot = seekParent(node.expressions[node.expressions.length - 1], slot);\n                    }\n                    break;\n                case 'path':\n                    // last step in path\n                    node.tuple = true;\n                    var index = node.steps.length - 1;\n                    slot = seekParent(node.steps[index--], slot);\n                    while (slot.level > 0 && index >= 0) {\n                        // check previous steps\n                        slot = seekParent(node.steps[index--], slot);\n                    }\n                    break;\n                default:\n                    // error - can't derive ancestor\n                    throw {\n                        code: \"S0217\",\n                        token: node.type,\n                        position: node.position\n                    };\n            }\n            return slot;\n        };\n\n        var pushAncestry = function(result, value) {\n            if(typeof value.seekingParent !== 'undefined' || value.type === 'parent') {\n                var slots = (typeof value.seekingParent !== 'undefined') ? value.seekingParent : [];\n                if (value.type === 'parent') {\n                    slots.push(value.slot);\n                }\n                if(typeof result.seekingParent === 'undefined') {\n                    result.seekingParent = slots;\n                } else {\n                    Array.prototype.push.apply(result.seekingParent, slots);\n                }\n            }\n        };\n\n        var resolveAncestry = function(path) {\n            var index = path.steps.length - 1;\n            var laststep = path.steps[index];\n            var slots = (typeof laststep.seekingParent !== 'undefined') ? laststep.seekingParent : [];\n            if (laststep.type === 'parent') {\n                slots.push(laststep.slot);\n            }\n            for(var is = 0; is < slots.length; is++) {\n                var slot = slots[is];\n                index = path.steps.length - 2;\n                while (slot.level > 0) {\n                    if (index < 0) {\n                        if(typeof path.seekingParent === 'undefined') {\n                            path.seekingParent = [slot];\n                        } else {\n                            path.seekingParent.push(slot);\n                        }\n                        break;\n                    }\n                    // try previous step\n                    var step = path.steps[index--];\n                    // multiple contiguous steps that bind the focus should be skipped\n                    while(index >= 0 && step.focus && path.steps[index].focus) {\n                        step = path.steps[index--];\n                    }\n                    slot = seekParent(step, slot);\n                }\n            }\n        };\n\n        // post-parse stage\n        // the purpose of this is to add as much semantic value to the parse tree as possible\n        // in order to simplify the work of the evaluator.\n        // This includes flattening the parts of the AST representing location paths,\n        // converting them to arrays of steps which in turn may contain arrays of predicates.\n        // following this, nodes containing '.' and '[' should be eliminated from the AST.\n        var processAST = function (expr) {\n            var result;\n            switch (expr.type) {\n                case 'binary':\n                    switch (expr.value) {\n                        case '.':\n                            var lstep = processAST(expr.lhs);\n\n                            if (lstep.type === 'path') {\n                                result = lstep;\n                            } else {\n                                result = {type: 'path', steps: [lstep]};\n                            }\n                            if(lstep.type === 'parent') {\n                                result.seekingParent = [lstep.slot];\n                            }\n                            var rest = processAST(expr.rhs);\n                            if (rest.type === 'function' &&\n                                rest.procedure.type === 'path' &&\n                                rest.procedure.steps.length === 1 &&\n                                rest.procedure.steps[0].type === 'name' &&\n                                result.steps[result.steps.length - 1].type === 'function') {\n                                // next function in chain of functions - will override a thenable\n                                result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;\n                            }\n                            if (rest.type === 'path') {\n                                Array.prototype.push.apply(result.steps, rest.steps);\n                            } else {\n                                if(typeof rest.predicate !== 'undefined') {\n                                    rest.stages = rest.predicate;\n                                    delete rest.predicate;\n                                }\n                                result.steps.push(rest);\n                            }\n                            // any steps within a path that are string literals, should be changed to 'name'\n                            result.steps.filter(function (step) {\n                                if (step.type === 'number' || step.type === 'value') {\n                                    // don't allow steps to be numbers or the values true/false/null\n                                    throw {\n                                        code: \"S0213\",\n                                        stack: (new Error()).stack,\n                                        position: step.position,\n                                        value: step.value\n                                    };\n                                }\n                                return step.type === 'string';\n                            }).forEach(function (lit) {\n                                lit.type = 'name';\n                            });\n                            // any step that signals keeping a singleton array, should be flagged on the path\n                            if (result.steps.filter(function (step) {\n                                return step.keepArray === true;\n                            }).length > 0) {\n                                result.keepSingletonArray = true;\n                            }\n                            // if first step is a path constructor, flag it for special handling\n                            var firststep = result.steps[0];\n                            if (firststep.type === 'unary' && firststep.value === '[') {\n                                firststep.consarray = true;\n                            }\n                            // if the last step is an array constructor, flag it so it doesn't flatten\n                            var laststep = result.steps[result.steps.length - 1];\n                            if (laststep.type === 'unary' && laststep.value === '[') {\n                                laststep.consarray = true;\n                            }\n                            resolveAncestry(result);\n                            break;\n                        case '[':\n                            // predicated step\n                            // LHS is a step or a predicated step\n                            // RHS is the predicate expr\n                            result = processAST(expr.lhs);\n                            var step = result;\n                            var type = 'predicate';\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                                type = 'stages';\n                            }\n                            if (typeof step.group !== 'undefined') {\n                                throw {\n                                    code: \"S0209\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if (typeof step[type] === 'undefined') {\n                                step[type] = [];\n                            }\n                            var predicate = processAST(expr.rhs);\n                            if(typeof predicate.seekingParent !== 'undefined') {\n                                predicate.seekingParent.forEach(slot => {\n                                    if(slot.level === 1) {\n                                        seekParent(step, slot);\n                                    } else {\n                                        slot.level--;\n                                    }\n                                });\n                                pushAncestry(step, predicate);\n                            }\n                            step[type].push({type: 'filter', expr: predicate, position: expr.position});\n                            break;\n                        case '{':\n                            // group-by\n                            // LHS is a step or a predicated step\n                            // RHS is the object constructor expr\n                            result = processAST(expr.lhs);\n                            if (typeof result.group !== 'undefined') {\n                                throw {\n                                    code: \"S0210\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // object constructor - process each pair\n                            result.group = {\n                                lhs: expr.rhs.map(function (pair) {\n                                    return [processAST(pair[0]), processAST(pair[1])];\n                                }),\n                                position: expr.position\n                            };\n                            break;\n                        case '^':\n                            // order-by\n                            // LHS is the array to be ordered\n                            // RHS defines the terms\n                            result = processAST(expr.lhs);\n                            if (result.type !== 'path') {\n                                result = {type: 'path', steps: [result]};\n                            }\n                            var sortStep = {type: 'sort', position: expr.position};\n                            sortStep.terms = expr.rhs.map(function (terms) {\n                                var expression = processAST(terms.expression);\n                                pushAncestry(sortStep, expression);\n                                return {\n                                    descending: terms.descending,\n                                    expression: expression\n                                };\n                            });\n                            result.steps.push(sortStep);\n                            resolveAncestry(result);\n                            break;\n                        case ':=':\n                            result = {type: 'bind', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.rhs);\n                            break;\n                        case '@':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            }\n                            // throw error if there are any predicates defined at this point\n                            // at this point the only type of stages can be predicates\n                            if(typeof step.stages !== 'undefined' || typeof step.predicate !== 'undefined') {\n                                throw {\n                                    code: \"S0215\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // also throw if this is applied after an 'order-by' clause\n                            if(step.type === 'sort') {\n                                throw {\n                                    code: \"S0216\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if(expr.keepArray) {\n                                step.keepArray = true;\n                            }\n                            step.focus = expr.rhs.value;\n                            step.tuple = true;\n                            break;\n                        case '#':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            } else {\n                                result = {type: 'path', steps: [result]};\n                                if (typeof step.predicate !== 'undefined') {\n                                    step.stages = step.predicate;\n                                    delete step.predicate;\n                                }\n                            }\n                            if (typeof step.stages === 'undefined') {\n                                step.index = expr.rhs.value;\n                            } else {\n                                step.stages.push({type: 'index', value: expr.rhs.value, position: expr.position});\n                            }\n                            step.tuple = true;\n                            break;\n                        case '~>':\n                            result = {type: 'apply', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            result.keepArray = result.lhs.keepArray || result.rhs.keepArray;\n                            break;\n                        default:\n                            result = {type: expr.type, value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.lhs);\n                            pushAncestry(result, result.rhs);\n                    }\n                    break;\n                case 'unary':\n                    result = {type: expr.type, value: expr.value, position: expr.position};\n                    if (expr.value === '[') {\n                        // array constructor - process each item\n                        result.expressions = expr.expressions.map(function (item) {\n                            var value = processAST(item);\n                            pushAncestry(result, value);\n                            return value;\n                        });\n                    } else if (expr.value === '{') {\n                        // object constructor - process each pair\n                        result.lhs = expr.lhs.map(function (pair) {\n                            var key = processAST(pair[0]);\n                            pushAncestry(result, key);\n                            var value = processAST(pair[1]);\n                            pushAncestry(result, value);\n                            return [key, value];\n                        });\n                    } else {\n                        // all other unary expressions - just process the expression\n                        result.expression = processAST(expr.expression);\n                        // if unary minus on a number, then pre-process\n                        if (expr.value === '-' && result.expression.type === 'number') {\n                            result = result.expression;\n                            result.value = -result.value;\n                        } else {\n                            pushAncestry(result, result.expression);\n                        }\n                    }\n                    break;\n                case 'function':\n                case 'partial':\n                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};\n                    result.arguments = expr.arguments.map(function (arg) {\n                        var argAST = processAST(arg);\n                        pushAncestry(result, argAST);\n                        return argAST;\n                    });\n                    result.procedure = processAST(expr.procedure);\n                    break;\n                case 'lambda':\n                    result = {\n                        type: expr.type,\n                        arguments: expr.arguments,\n                        signature: expr.signature,\n                        position: expr.position\n                    };\n                    var body = processAST(expr.body);\n                    result.body = tailCallOptimize(body);\n                    break;\n                case 'condition':\n                    result = {type: expr.type, position: expr.position};\n                    result.condition = processAST(expr.condition);\n                    pushAncestry(result, result.condition);\n                    result.then = processAST(expr.then);\n                    pushAncestry(result, result.then);\n                    if (typeof expr.else !== 'undefined') {\n                        result.else = processAST(expr.else);\n                        pushAncestry(result, result.else);\n                    }\n                    break;\n                case 'transform':\n                    result = {type: expr.type, position: expr.position};\n                    result.pattern = processAST(expr.pattern);\n                    result.update = processAST(expr.update);\n                    if (typeof expr.delete !== 'undefined') {\n                        result.delete = processAST(expr.delete);\n                    }\n                    break;\n                case 'block':\n                    result = {type: expr.type, position: expr.position};\n                    // array of expressions - process each one\n                    result.expressions = expr.expressions.map(function (item) {\n                        var part = processAST(item);\n                        pushAncestry(result, part);\n                        if (part.consarray || (part.type === 'path' && part.steps[0].consarray)) {\n                            result.consarray = true;\n                        }\n                        return part;\n                    });\n                    // TODO scan the array of expressions to see if any of them assign variables\n                    // if so, need to mark the block as one that needs to create a new frame\n                    break;\n                case 'name':\n                    result = {type: 'path', steps: [expr]};\n                    if (expr.keepArray) {\n                        result.keepSingletonArray = true;\n                    }\n                    break;\n                case 'parent':\n                    result = {type: 'parent', slot: { label: '!' + ancestorLabel++, level: 1, index: ancestorIndex++ } };\n                    ancestry.push(result);\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                case 'wildcard':\n                case 'descendant':\n                case 'variable':\n                case 'regex':\n                    result = expr;\n                    break;\n                case 'operator':\n                    // the tokens 'and' and 'or' might have been used as a name rather than an operator\n                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {\n                        expr.type = 'name';\n                        result = processAST(expr);\n                    } else /* istanbul ignore else */ if (expr.value === '?') {\n                        // partial application\n                        result = expr;\n                    } else {\n                        throw {\n                            code: \"S0201\",\n                            stack: (new Error()).stack,\n                            position: expr.position,\n                            token: expr.value\n                        };\n                    }\n                    break;\n                case 'error':\n                    result = expr;\n                    if (expr.lhs) {\n                        result = processAST(expr.lhs);\n                    }\n                    break;\n                default:\n                    var code = \"S0206\";\n                    /* istanbul ignore else */\n                    if (expr.id === '(end)') {\n                        code = \"S0207\";\n                    }\n                    var err = {\n                        code: code,\n                        position: expr.position,\n                        token: expr.value\n                    };\n                    if (recover) {\n                        errors.push(err);\n                        return {type: 'error', error: err};\n                    } else {\n                        err.stack = (new Error()).stack;\n                        throw err;\n                    }\n            }\n            if (expr.keepArray) {\n                result.keepArray = true;\n            }\n            return result;\n        };\n\n        // now invoke the tokenizer and the parser and return the syntax tree\n        lexer = tokenizer(source);\n        advance();\n        // parse the tokens\n        var expr = expression(0);\n        if (node.id !== '(end)') {\n            var err = {\n                code: \"S0201\",\n                position: node.position,\n                token: node.value\n            };\n            handleError(err);\n        }\n        expr = processAST(expr);\n\n        if(expr.type === 'parent' || typeof expr.seekingParent !== 'undefined') {\n            // error - trying to derive ancestor at top level\n            throw {\n                code: \"S0217\",\n                token: expr.type,\n                position: expr.position\n            };\n        }\n\n        if (errors.length > 0) {\n            expr.errors = errors;\n        }\n\n        return expr;\n    };\n\n    return parser;\n})();\n\nmodule.exports = parser;\n\n},{\"./signature\":5}],5:[function(require,module,exports){\n/**\n * \u00A9 Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst signature = (() => {\n    'use strict';\n\n    // A mapping between the function signature symbols and the full plural of the type\n    // Expected to be used in error messages\n    var arraySignatureMapping = {\n        \"a\": \"arrays\",\n        \"b\": \"booleans\",\n        \"f\": \"functions\",\n        \"n\": \"numbers\",\n        \"o\": \"objects\",\n        \"s\": \"strings\"\n    };\n\n    /**\n     * Parses a function signature definition and returns a validation function\n     * @param {string} signature - the signature between the <angle brackets>\n     * @returns {Function} validation function\n     */\n    function parseSignature(signature) {\n        // create a Regex that represents this signature and return a function that when invoked,\n        // returns the validated (possibly fixed-up) arguments, or throws a validation error\n        // step through the signature, one symbol at a time\n        var position = 1;\n        var params = [];\n        var param = {};\n        var prevParam = param;\n        while (position < signature.length) {\n            var symbol = signature.charAt(position);\n            if (symbol === ':') {\n                // TODO figure out what to do with the return type\n                // ignore it for now\n                break;\n            }\n\n            var next = function () {\n                params.push(param);\n                prevParam = param;\n                param = {};\n            };\n\n            var findClosingBracket = function (str, start, openSymbol, closeSymbol) {\n                // returns the position of the closing symbol (e.g. bracket) in a string\n                // that balances the opening symbol at position start\n                var depth = 1;\n                var position = start;\n                while (position < str.length) {\n                    position++;\n                    symbol = str.charAt(position);\n                    if (symbol === closeSymbol) {\n                        depth--;\n                        if (depth === 0) {\n                            // we're done\n                            break; // out of while loop\n                        }\n                    } else if (symbol === openSymbol) {\n                        depth++;\n                    }\n                }\n                return position;\n            };\n\n            switch (symbol) {\n                case 's': // string\n                case 'n': // number\n                case 'b': // boolean\n                case 'l': // not so sure about expecting null?\n                case 'o': // object\n                    param.regex = '[' + symbol + 'm]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'a': // array\n                    //  normally treat any value as singleton array\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    param.array = true;\n                    next();\n                    break;\n                case 'f': // function\n                    param.regex = 'f';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'j': // any JSON type\n                    param.regex = '[asnblom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'x': // any type\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case '-': // use context if param not supplied\n                    prevParam.context = true;\n                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime\n                    prevParam.regex += '?';\n                    break;\n                case '?': // optional param\n                case '+': // one or more\n                    prevParam.regex += symbol;\n                    break;\n                case '(': // choice of types\n                    // search forward for matching ')'\n                    var endParen = findClosingBracket(signature, position, '(', ')');\n                    var choice = signature.substring(position + 1, endParen);\n                    if (choice.indexOf('<') === -1) {\n                        // no parameterized types, simple regex\n                        param.regex = '[' + choice + 'm]';\n                    } else {\n                        // TODO harder\n                        throw {\n                            code: \"S0402\",\n                            stack: (new Error()).stack,\n                            value: choice,\n                            offset: position\n                        };\n                    }\n                    param.type = '(' + choice + ')';\n                    position = endParen;\n                    next();\n                    break;\n                case '<': // type parameter - can only be applied to 'a' and 'f'\n                    if (prevParam.type === 'a' || prevParam.type === 'f') {\n                        // search forward for matching '>'\n                        var endPos = findClosingBracket(signature, position, '<', '>');\n                        prevParam.subtype = signature.substring(position + 1, endPos);\n                        position = endPos;\n                    } else {\n                        throw {\n                            code: \"S0401\",\n                            stack: (new Error()).stack,\n                            value: prevParam.type,\n                            offset: position\n                        };\n                    }\n                    break;\n            }\n            position++;\n        }\n        var regexStr = '^' +\n            params.map(function (param) {\n                return '(' + param.regex + ')';\n            }).join('') +\n            '$';\n        var regex = new RegExp(regexStr);\n        var getSymbol = function (value) {\n            var symbol;\n            if (utils.isFunction(value)) {\n                symbol = 'f';\n            } else {\n                var type = typeof value;\n                switch (type) {\n                    case 'string':\n                        symbol = 's';\n                        break;\n                    case 'number':\n                        symbol = 'n';\n                        break;\n                    case 'boolean':\n                        symbol = 'b';\n                        break;\n                    case 'object':\n                        if (value === null) {\n                            symbol = 'l';\n                        } else if (Array.isArray(value)) {\n                            symbol = 'a';\n                        } else {\n                            symbol = 'o';\n                        }\n                        break;\n                    case 'undefined':\n                    default:\n                        // any value can be undefined, but should be allowed to match\n                        symbol = 'm'; // m for missing\n                }\n            }\n            return symbol;\n        };\n\n        var throwValidationError = function (badArgs, badSig) {\n            // to figure out where this went wrong we need apply each component of the\n            // regex to each argument until we get to the one that fails to match\n            var partialPattern = '^';\n            var goodTo = 0;\n            for (var index = 0; index < params.length; index++) {\n                partialPattern += params[index].regex;\n                var match = badSig.match(partialPattern);\n                if (match === null) {\n                    // failed here\n                    throw {\n                        code: \"T0410\",\n                        stack: (new Error()).stack,\n                        value: badArgs[goodTo],\n                        index: goodTo + 1\n                    };\n                }\n                goodTo = match[0].length;\n            }\n            // if it got this far, it's probably because of extraneous arguments (we\n            // haven't added the trailing '$' in the regex yet.\n            throw {\n                code: \"T0410\",\n                stack: (new Error()).stack,\n                value: badArgs[goodTo],\n                index: goodTo + 1\n            };\n        };\n\n        return {\n            definition: signature,\n            validate: function (args, context) {\n                var suppliedSig = '';\n                args.forEach(function (arg) {\n                    suppliedSig += getSymbol(arg);\n                });\n                var isValid = regex.exec(suppliedSig);\n                if (isValid) {\n                    var validatedArgs = [];\n                    var argIndex = 0;\n                    params.forEach(function (param, index) {\n                        var arg = args[argIndex];\n                        var match = isValid[index + 1];\n                        if (match === '') {\n                            if (param.context && param.contextRegex) {\n                                // substitute context value for missing arg\n                                // first check that the context value is the right type\n                                var contextType = getSymbol(context);\n                                // test contextType against the regex for this arg (without the trailing ?)\n                                if (param.contextRegex.test(contextType)) {\n                                    validatedArgs.push(context);\n                                } else {\n                                    // context value not compatible with this argument\n                                    throw {\n                                        code: \"T0411\",\n                                        stack: (new Error()).stack,\n                                        value: context,\n                                        index: argIndex + 1\n                                    };\n                                }\n                            } else {\n                                validatedArgs.push(arg);\n                                argIndex++;\n                            }\n                        } else {\n                            // may have matched multiple args (if the regex ends with a '+'\n                            // split into single tokens\n                            match.split('').forEach(function (single) {\n                                if (param.type === 'a') {\n                                    if (single === 'm') {\n                                        // missing (undefined)\n                                        arg = undefined;\n                                    } else {\n                                        arg = args[argIndex];\n                                        var arrayOK = true;\n                                        // is there type information on the contents of the array?\n                                        if (typeof param.subtype !== 'undefined') {\n                                            if (single !== 'a' && match !== param.subtype) {\n                                                arrayOK = false;\n                                            } else if (single === 'a') {\n                                                if (arg.length > 0) {\n                                                    var itemType = getSymbol(arg[0]);\n                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further\n                                                        arrayOK = false;\n                                                    } else {\n                                                        // make sure every item in the array is this type\n                                                        var differentItems = arg.filter(function (val) {\n                                                            return (getSymbol(val) !== itemType);\n                                                        });\n                                                        arrayOK = (differentItems.length === 0);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (!arrayOK) {\n                                            throw {\n                                                code: \"T0412\",\n                                                stack: (new Error()).stack,\n                                                value: arg,\n                                                index: argIndex + 1,\n                                                type: arraySignatureMapping[param.subtype]\n                                            };\n                                        }\n                                        // the function expects an array. If it's not one, make it so\n                                        if (single !== 'a') {\n                                            arg = [arg];\n                                        }\n                                    }\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                } else {\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                }\n                            });\n                        }\n                    });\n                    return validatedArgs;\n                }\n                throwValidationError(args, suppliedSig);\n            }\n        };\n    }\n\n    return parseSignature;\n})();\n\nmodule.exports = signature;\n\n},{\"./utils\":6}],6:[function(require,module,exports){\n/**\n * \u00A9 Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = (() => {\n    'use strict';\n\n    /**\n     * Check if value is a finite number\n     * @param {float} n - number to evaluate\n     * @returns {boolean} True if n is a finite number\n     */\n    function isNumeric(n) {\n        var isNum = false;\n        if(typeof n === 'number') {\n            isNum = !isNaN(n);\n            if (isNum && !isFinite(n)) {\n                throw {\n                    code: \"D1001\",\n                    value: n,\n                    stack: (new Error()).stack\n                };\n            }\n        }\n        return isNum;\n    }\n\n    /**\n     * Returns true if the arg is an array of strings\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of strings\n     */\n    function isArrayOfStrings(arg) {\n        var result = false;\n        /* istanbul ignore else */\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if the arg is an array of numbers\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of numbers\n     */\n    function isArrayOfNumbers(arg) {\n        var result = false;\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Create an empty sequence to contain query results\n     * @returns {Array} - empty sequence\n     */\n    function createSequence() {\n        var sequence = [];\n        sequence.sequence = true;\n        if (arguments.length === 1) {\n            sequence.push(arguments[0]);\n        }\n        return sequence;\n    }\n\n    /**\n     * Tests if a value is a sequence\n     * @param {*} value the value to test\n     * @returns {boolean} true if it's a sequence\n     */\n    function isSequence(value) {\n        return value.sequence === true && Array.isArray(value);\n    }\n\n    /**\n     *\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a function (lambda or built-in)\n     */\n    function isFunction(arg) {\n        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');\n    }\n\n    /**\n     * Returns the arity (number of arguments) of the function\n     * @param {*} func - the function\n     * @returns {*} - the arity\n     */\n    function getFunctionArity(func) {\n        var arity = typeof func.arity === 'number' ? func.arity :\n            typeof func.implementation === 'function' ? func.implementation.length :\n                typeof func.length === 'number' ? func.length : func.arguments.length;\n        return arity;\n    }\n\n    /**\n     * Tests whether arg is a lambda function\n     * @param {*} arg - the value to test\n     * @returns {boolean} - true if it is a lambda function\n     */\n    function isLambda(arg) {\n        return arg && arg._jsonata_lambda === true;\n    }\n\n    // istanbul ignore next\n    var iteratorSymbol = (typeof Symbol === \"function\" ? Symbol : {}).iterator || \"@@iterator\";\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is iterable\n     */\n    function isIterable(arg) {\n        return (\n            typeof arg === 'object' &&\n            arg !== null &&\n            iteratorSymbol in arg &&\n            'next' in arg &&\n            typeof arg.next === 'function'\n        );\n    }\n\n    /**\n     * Compares two values for equality\n     * @param {*} lhs first value\n     * @param {*} rhs second value\n     * @returns {boolean} true if they are deep equal\n     */\n    function isDeepEqual(lhs, rhs) {\n        if (lhs === rhs) {\n            return true;\n        }\n        if(typeof lhs === 'object' && typeof rhs === 'object' && lhs !== null && rhs !== null) {\n            if(Array.isArray(lhs) && Array.isArray(rhs)) {\n                // both arrays (or sequences)\n                // must be the same length\n                if(lhs.length !== rhs.length) {\n                    return false;\n                }\n                // must contain same values in same order\n                for(var ii = 0; ii < lhs.length; ii++) {\n                    if(!isDeepEqual(lhs[ii], rhs[ii])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            // both objects\n            // must have the same set of keys (in any order)\n            var lkeys = Object.getOwnPropertyNames(lhs);\n            var rkeys = Object.getOwnPropertyNames(rhs);\n            if(lkeys.length !== rkeys.length) {\n                return false;\n            }\n            lkeys = lkeys.sort();\n            rkeys = rkeys.sort();\n            for(ii=0; ii < lkeys.length; ii++) {\n                if(lkeys[ii] !== rkeys[ii]) {\n                    return false;\n                }\n            }\n            // must have the same values\n            for(ii=0; ii < lkeys.length; ii++) {\n                var key = lkeys[ii];\n                if(!isDeepEqual(lhs[key], rhs[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a promise\n     */\n    function isPromise(arg) {\n        return (\n            typeof arg === 'object' &&\n                arg !== null &&\n                'then' in arg &&\n                typeof arg.then === 'function'\n        );\n    }\n\n    /**\n     * converts a string to an array of characters\n     * @param {string} str - the input string\n     * @returns {Array} - the array of characters\n     */\n    function stringToArray(str) {\n        var arr = [];\n        for (let char of str) {\n            arr.push(char);\n        }\n        return arr;\n    }\n\n    return {\n        isNumeric,\n        isArrayOfStrings,\n        isArrayOfNumbers,\n        createSequence,\n        isSequence,\n        isFunction,\n        isLambda,\n        isIterable,\n        getFunctionArity,\n        isDeepEqual,\n        stringToArray,\n        isPromise\n    };\n})();\n\nmodule.exports = utils;\n\n},{}]},{},[3])(3)\n});\n", "// @ts-check\r\nimport jsonata from 'jsonata';\r\n\r\nexport class Orchestrator {\r\n  /** @type {Object<string, any>} */\r\n  #functions = {};\r\n\r\n  #explicitItisOnly = false;\r\n  \r\n  /**\r\n   * @typedef {Object} State\r\n   * @property {Object<string, any>} results \r\n   * @property {Object} variables\r\n   * @property {Object<string, any>} variables.global\r\n   * @property {Array<any>} variables.locals\r\n   */\r\n  /** @type {State} */\r\n  #state = {\r\n    results: {},\r\n    variables: {\r\n      global: {},\r\n      locals: []\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @typedef {Object} StateHandler\r\n   * @property {function|null} set \r\n   * @property {function|null} get\r\n   */\r\n  /** @type {StateHandler} */\r\n  // @ts-ignore\r\n  #stateHandler = {\r\n    set: null,\r\n    get: null\r\n  };\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {Object} [config]\r\n   * @param {Record<string, any>} [config.functions] A JSON object containing as key the function name and as value the function\r\n   * @param {boolean} [config.explicitItisOnly] When true only the user specified init functions are used. When false initial functions will be automatically discovered. (Default false)\r\n   * @example\r\n   *  new Orchestrator({\r\n   *    functions: {\r\n   *      fn1: async a=>a,\r\n   *      fn2: async a=>a\r\n   *    },\r\n   *    explicitItisOnly: false\r\n   * });\r\n   */\r\n  constructor ({ functions = {}, explicitItisOnly = false } = {}) {\r\n    this.#functions = functions;\r\n    this.#explicitItisOnly = explicitItisOnly;\r\n  }\r\n\r\n  /*\r\n  stateHandler ({\r\n    setState=null,\r\n    getState=null\r\n  }) {\r\n    this.#stateHandler.set = setState;\r\n    this.#stateHandler.get = getState;\r\n  }*/\r\n\r\n  /**\r\n   * @typedef {Object} Connection The connections between the services provided as an array of objects with the following properties:\r\n   * @property {string[]} from The list of the connections from where the data is coming from\r\n   * @property {string|undefined} [transition] The JSONata to process the data\r\n   * @property {string[]|undefined} [to] The list of the connections to where the data is going to\r\n   */\r\n\r\n  /**\r\n   * Run the Orchestrator\r\n   * @param {Object} [config]\r\n   * @param {Object<string, any>} [config.inits] A JSON object containing as key the function name and as value an array of parameters to use as input for the funciton\r\n   * @param {Connection[]} [config.connections] The connections between the services provided as an array of objects with the following properties:\r\n   * - from:       The list of the connections from where the data is coming from (string[])\r\n   * - transition: The JSONata to process the data  (optional, string)\r\n   * - to:         The list of the connections to where the data is going to  (optional, string[])\r\n   * @returns {Promise<State>} A promise that resolves with the results of the Orchestrator\r\n   * @example\r\n   *  await run({\r\n   *    inits: {\r\n   *      fn1: [\"Hello\"]\r\n   *    },\r\n   *    connections: [{\r\n   *      from: ['fn1'],\r\n   *      transition: '{\"global\":$.global, \"local\":$.local, \"to\":[[$.from[0] & \" World\"]]}',\r\n   *      to: ['fn2']\r\n   *    }, {\r\n   *      from: ['fn2'],\r\n   *      to: []\r\n   *    }]\r\n   *  });\r\n   *\r\n   * output:\r\n   *  {\r\n   *    results: { connection_1: [ 'Hello World' ] },\r\n   *    variables: { global: {}, locals: [ {}, {} ] }\r\n   *  }\r\n   */\r\n\r\n  async run ({ \r\n    inits = {},\r\n    connections = []\r\n  } = {}) {\r\n    this.#state.results = {};\r\n\r\n    if (this.#explicitItisOnly && Object.keys(inits).length === 0) throw new Error('When \"explicitItisOnly\" is true, \"inits\" cannot be empty.');\r\n\r\n    if (!this.#explicitItisOnly) {\r\n      /** @type {Object<string, any>} */\r\n      const autoInits = {};\r\n      for (const connection of connections) {\r\n        for(const from of connection.from ?? []) {\r\n          autoInits[from] = [];\r\n        }\r\n        for(const to of connection.to ?? []) {\r\n          if (autoInits[to]) {\r\n            delete autoInits[to];\r\n          }\r\n        }\r\n      }\r\n      for(const fnId of Object.keys(autoInits)) {\r\n        if (!inits[fnId])\r\n          inits[fnId] = autoInits[fnId];\r\n      }\r\n    }\r\n\r\n    //run the functions for which we have initial inputs\r\n    for(const fnId of Object.keys(inits)) {\r\n      if (this.#functions[fnId]) {\r\n        this.#state.results[fnId] = Promise.resolve(this.#functions[fnId](...inits[fnId]));\r\n      }\r\n    }\r\n\r\n    //check for every connection if all the from outputs are availables\r\n    this.#state.variables = {\r\n      global: {},\r\n      locals: new Array(connections.length).fill(null).map(() => ({}))\r\n    };\r\n    const connectionsCheck = async () => {\r\n      let canContinue;\r\n      do {\r\n        canContinue = false;\r\n        for (let connectionIndex = 0; connectionIndex < connections.length; connectionIndex++) {\r\n          const connection = connections[connectionIndex];\r\n          let canStart = true;\r\n          const outputsAwaitList = [];\r\n          const fromList = connection.from ?? [];\r\n          if (fromList.length === 0) throw new Error(`The connection ${connectionIndex} from is an empty array.\\nConnection: ${JSON.stringify(connection)}`);\r\n          for (const from of fromList) {\r\n            if (!Object.hasOwn(this.#state.results, from)) {\r\n              canStart = false;\r\n              break;\r\n            } else {\r\n              outputsAwaitList.push(this.#state.results[from]);\r\n            }\r\n          }\r\n          if (canStart) {\r\n            /** @type {Object<string, any>} */\r\n            const placeholders = {};\r\n            const addPlaceholders = (/** @type {any} */ output) => {\r\n              const type = typeof output;\r\n              if (type === 'function' || type === 'symbol') {\r\n                const placeholder = globalThis.crypto.randomUUID();\r\n                placeholders[placeholder] = output;\r\n                return placeholder;\r\n              } else if (type === 'object') {\r\n                if (output === null) return null;\r\n                const isArray = Array.isArray(output);\r\n                const obj = isArray ? [] : {};\r\n                for (const el of isArray ? output : Object.keys(output)) {\r\n                  // @ts-ignore\r\n                  isArray ? obj.push(addPlaceholders(el)) : obj[el] = addPlaceholders(output[el]);\r\n                }\r\n                return obj;\r\n              } else {\r\n                return output;\r\n              }\r\n            };\r\n            const restorePlaceholders = (/** @type {any} */ input) => {\r\n              const type = typeof input;\r\n              if (type === 'string') {\r\n                for (const placeholder of Object.keys(placeholders)) {\r\n                  if (input === placeholder) {\r\n                    return placeholders[placeholder];\r\n                  }\r\n                }\r\n                return input;\r\n              } else if (type === 'object') {\r\n                if (input === null) return null;\r\n                const isArray = Array.isArray(input);\r\n                const obj = isArray ? [] : {};\r\n                for (const el of isArray ? input : Object.keys(input)) {\r\n                  // @ts-ignore\r\n                  isArray ? obj.push(restorePlaceholders(el)) : obj[el] = restorePlaceholders(input[el]);\r\n                }\r\n                return obj;\r\n              } else {\r\n                return input;\r\n              }\r\n            };\r\n\r\n            //wait all the outputs of the froms to be resolved and apply placeholders for symbols and functions\r\n            const outputsList = (await Promise.all(outputsAwaitList)).map(addPlaceholders);\r\n            //remove all the outputs of the froms\r\n            for (const from of fromList) {\r\n              delete this.#state.results[from];\r\n            }\r\n            //we process all the outputs generating all the to inputs and call the execution of all the to where the processed inputs are not null\r\n            canContinue = true;\r\n            const toList = connection.to ?? [];\r\n            let transitionResults = {\r\n              to: outputsList.map(obj=>[obj]), //when no transition is defined the output of the froms are gived as first argument input parameter for the to\r\n              global: this.#state.variables.global,\r\n              local: this.#state.variables.locals[connectionIndex]\r\n            };\r\n            if (connection.transition) {\r\n              try {\r\n                const transitionInput = { \r\n                  from: outputsList, \r\n                  global: this.#state.variables.global, \r\n                  local: this.#state.variables.locals[connectionIndex]\r\n                };\r\n                //console.dir(transitionInput, {depth: null});\r\n                transitionResults = await jsonata(connection.transition).evaluate(transitionInput);\r\n                //console.dir(transitionResults, {depth: null});\r\n              } catch(error) {\r\n                // @ts-ignore\r\n                throw new Error(`Connection ${connectionIndex} transition: ${error.message}`);\r\n              }\r\n            }\r\n            const inputsList = transitionResults.to;\r\n            this.#state.variables.global = transitionResults.global ?? this.#state.variables.global;\r\n            this.#state.variables.locals[connectionIndex] = transitionResults.local ?? this.#state.variables.locals[connectionIndex];\r\n            if(toList.length > 0) {\r\n              if (!Array.isArray(inputsList)) throw new Error(`The transition returned value must be an array.\\nReturned: ${JSON.stringify(inputsList)}\\nConnection: ${JSON.stringify(connection)}`);\r\n              if (inputsList.length != toList.length) throw new Error(`The transition returned value must be an array of the same length of the connection.to array.\\nReturned: ${JSON.stringify(inputsList)}\\nConnection: ${JSON.stringify(connection)}`);\r\n              for (let i=0; i<toList.length; i++) {\r\n                const to = toList[i];\r\n                const inputs = restorePlaceholders(inputsList[i]);\r\n                if (inputs == null)\r\n                  continue;\r\n                this.#state.results[to] = Promise.resolve(this.#functions?.[to](...inputs));\r\n              }\r\n            } else {\r\n              this.#state.results['connection_' + connectionIndex] = inputsList;\r\n            }\r\n          }\r\n        }\r\n        //will be done until no additional executions have been done\r\n      } while (canContinue);\r\n    };\r\n\r\n    await connectionsCheck();\r\n\r\n    //wait for all the results to be resolved\r\n    for(const fnId of Object.keys(this.#state.results)) {\r\n      this.#state.results[fnId] = await this.#state.results[fnId];\r\n    }\r\n    return {\r\n      results: this.#state.results,\r\n      variables: this.#state.variables\r\n    };\r\n  }\r\n}"],
  "mappings": "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",
  "names": ["require_jsonata", "__commonJSMin", "exports", "module", "f", "g", "define", "r", "e", "n", "t", "o", "i", "c", "__require", "u", "a", "p", "require", "utils", "dateTime", "stringToArray", "few", "ordinals", "decades", "magnitudes", "numberToWords", "value", "ordinal", "lookup", "num", "prev", "ord", "words", "tens", "remainder", "hundreds", "mag", "factor", "mant", "wordValues", "word", "index", "lword", "val", "wordsToNumber", "text", "values", "part", "segs", "top", "b", "romanNumerals", "romanValues", "decimalToRoman", "numeral", "romanToDecimal", "roman", "decimal", "max", "digit", "decimalToLetters", "aChar", "letters", "aCode", "lettersToDecimal", "formatInteger", "picture", "format", "analyseIntegerPicture", "_formatInteger", "formats", "tcase", "formattedInteger", "negative", "padLength", "padding", "code", "ii", "pos", "separator", "suffix123", "lastDigit", "suffix", "decimalGroups", "primaryFormat", "formatModifier", "semicolon", "zeroCode", "mandatoryDigits", "optionalDigits", "groupingSeparators", "separatorPosition", "codePoint", "group", "regular", "separators", "sepChar", "indexes", "gcd", "defaultPresentationModifiers", "analyseDateTimePicture", "spec", "addLiteral", "start", "end", "literal", "marker", "def", "comma", "presMod", "widthMod", "dash", "min", "parseWidth", "wm", "widthDef", "lastChar", "integerPattern", "w", "previousPart", "days", "months", "millisInADay", "startOfFirstWeek", "ym", "jan1", "dayOfJan1", "yearMonth", "year", "month", "deltaWeeks", "getDateTimeFragment", "date", "component", "componentValue", "today", "firstJan", "thisYear", "startOfWeek1", "week", "startOfFollowingYear", "startOfPreviousYear", "thisMonth", "startOfFollowingMonth", "startOfPreviousMonth", "startOfISOYear", "endOfISOYear", "now", "startOfISOMonth", "nextMonth", "endOfISOMonth", "iso8601Spec", "formatDateTime", "millis", "timezone", "offsetHours", "offsetMinutes", "offset", "formatComponent", "markerSpec", "numDigits", "formatSpec", "offsetMillis", "result", "generateRegex", "matcher", "res", "name", "isUpper", "digits", "sep", "char", "parseInteger", "parseDateTime", "timestamp", "matchSpec", "fullRegex", "info", "components", "mpart", "mask", "shift", "bit", "isType", "type", "dateB", "dateC", "dateD", "timeB", "comps", "startSpecified", "endSpecified", "derivedDate", "iso8601regex", "toMillis", "fromMillis", "global", "functions", "isNumeric", "isArrayOfStrings", "isArrayOfNumbers", "createSequence", "isSequence", "isFunction", "isLambda", "isPromise", "getFunctionArity", "deepEquals", "sum", "args", "total", "count", "average", "string", "arg", "prettify", "str", "space", "key", "substring", "length", "strArray", "strLength", "substringBefore", "chars", "substringAfter", "lowercase", "uppercase", "trim", "pad", "width", "evaluateMatcher", "contains", "token", "matches", "match", "regex", "limit", "replace", "pattern", "replacement", "self", "replacer", "regexMatch", "substitute", "position", "dollarVal", "maxDigits", "submatch", "replacedWith", "base64encode", "btoa", "base64decode", "atob", "encodeUrlComponent", "returnVal", "encodeUrl", "decodeUrlComponent", "decodeUrl", "split", "join", "strs", "formatNumber", "options", "defaults", "properties", "decimalDigitFamily", "zeroCharCode", "activeChars", "subPictures", "splitParts", "subpicture", "prefix", "ch", "activePart", "mantissaPart", "exponentPart", "integerPart", "fractionalPart", "exponentPosition", "decimalPosition", "validate", "parts", "error", "decimalPos", "valid", "charTypes", "optionalDigitPos", "exponentExists", "analyse", "getGroupingPositions", "toLeft", "positions", "groupingPosition", "charsToTheRight", "integerPartGroupingPositions", "regularGrouping", "fractionalPartGroupingPositions", "minimumIntegerPartSize", "scalingFactor", "fractionalPartArray", "minimumFactionalPartSize", "maximumFactionalPartSize", "exponentPresent", "minimumExponentSize", "variables", "minus_sign", "zero_digit", "decimal_separator", "grouping_separator", "pic", "adjustedNumber", "mantissa", "exponent", "maxMantissa", "minMantissa", "roundedNumber", "round", "makeString", "dp", "stringValue", "padLeft", "padRight", "groupCount", "stringExponent", "formatBase", "radix", "number", "abs", "floor", "ceil", "precision", "diff", "sqrt", "power", "exp", "random", "boolean", "trues", "not", "hofFuncArgs", "func", "arg1", "arg2", "arg3", "func_args", "map", "arr", "filter", "entry", "single", "hasFoundMatch", "positiveResult", "zip", "tuple", "foldLeft", "sequence", "init", "arity", "keys", "merge", "item", "allkeys", "input", "append", "exists", "spread", "obj", "prop", "reverse", "each", "message", "assert", "condition", "sort", "comparator", "comp", "l", "merge_iter", "left", "right", "merged", "msort", "array", "middle", "shuffle", "j", "distinct", "results", "includes", "jj", "sift", "datetime", "fn", "parser", "parseSignature", "jsonata", "isIterable", "isDeepEqual", "staticFrame", "createFrame", "evaluate", "expr", "environment", "entryCallback", "evaluatePath", "evaluateBinary", "evaluateUnary", "evaluateName", "evaluateLiteral", "evaluateWildcard", "evaluateDescendants", "evaluateCondition", "evaluateBlock", "evaluateBindExpression", "evaluateRegex", "evaluateFunction", "evaluateVariable", "evaluateLambda", "evaluatePartialApplication", "evaluateApplyExpression", "evaluateTransformExpression", "evaluateFilter", "evaluateGroupExpression", "exitCallback", "inputSequence", "resultSequence", "isTupleStream", "tupleBindings", "step", "evaluateTupleStep", "evaluateStep", "createFrameFromTuple", "frame", "lastStep", "evaluateSortExpression", "evaluateStages", "ss", "stages", "stage", "ee", "sorted", "stepEnv", "bb", "predicate", "context", "env", "ires", "lhs", "op", "evalrhs", "evaluateBooleanExpression", "err", "rhs", "evaluateNumericExpression", "evaluateEqualityExpression", "evaluateComparisonExpression", "evaluateStringConcat", "evaluateRangeExpression", "evaluateIncludesExpression", "generators", "idx", "generator", "flatten", "flattened", "recurseDescendants", "member", "ltype", "rtype", "lcomparable", "rcomparable", "lBool", "boolize", "booledValue", "lstr", "rstr", "groups", "reduce", "itemIndex", "pairIndex", "pair", "reduceTupleStream", "tupleStream", "size", "re", "closure", "fromIndex", "next", "isTupleSort", "term", "aa", "atype", "btype", "focus", "transformer", "cloneFunction", "apply", "update", "updateType", "deletions", "defineFunction", "chainAST", "chain", "applyto", "proc", "evaluatedArgs", "params", "procName", "applyInner", "validatedArgs", "validateArguments", "applyProcedure", "procedure", "partialApplyProcedure", "partialApplyNativeFunction", "signature", "param", "applyNativeFunction", "unboundArgs", "native", "sigArgs", "getNativeFunctionArguments", "sigArg", "body", "bodyAST", "partial", "sigParens", "definition", "functionEval", "ast", "populateMessage", "functionClone", "enclosingEnvironment", "bindings", "newFrame", "framePushCallback", "errorCodes", "template", "errors", "callback", "exec_env", "v", "it", "implementation", "operators", "escapes", "tokenizer", "path", "create", "scanRegex", "depth", "flags", "isClosingSlash", "backslashCount", "currentChar", "commentStart", "quoteType", "qstr", "octets", "codepoint", "numregex", "source", "recover", "node", "lexer", "symbol_table", "remainingTokens", "remaining", "nxt", "base_symbol", "symbol", "id", "bp", "s", "handleError", "advance", "infix", "next_token", "expression", "rbp", "terminal", "led", "bindingPower", "infixr", "nud", "sigPos", "sig", "tok", "expressions", "range", "terms", "objectParser", "tailCallOptimize", "thunk", "ancestorLabel", "ancestorIndex", "ancestry", "seekParent", "slot", "pushAncestry", "slots", "resolveAncestry", "laststep", "is", "processAST", "lstep", "rest", "lit", "firststep", "sortStep", "argAST", "arraySignatureMapping", "prevParam", "findClosingBracket", "openSymbol", "closeSymbol", "endParen", "choice", "endPos", "regexStr", "getSymbol", "throwValidationError", "badArgs", "badSig", "partialPattern", "goodTo", "suppliedSig", "isValid", "argIndex", "contextType", "arrayOK", "itemType", "differentItems", "isNum", "iteratorSymbol", "lkeys", "rkeys", "import_jsonata", "Orchestrator", "#functions", "#explicitItisOnly", "#state", "#stateHandler", "functions", "explicitItisOnly", "inits", "connections", "autoInits", "connection", "from", "to", "fnId", "canContinue", "connectionIndex", "canStart", "outputsAwaitList", "fromList", "placeholders", "addPlaceholders", "output", "type", "placeholder", "isArray", "obj", "el", "restorePlaceholders", "input", "outputsList", "toList", "transitionResults", "transitionInput", "jsonata", "error", "inputsList", "i", "inputs"]
}
